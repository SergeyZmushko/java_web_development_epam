1. Как по терминологии Java называются базовый класс и наследуемый класс?  
**Ответ.**    
Класс производный от другого класса называется подкласс (subclass) (также производным классом , расширенным классом или дочерним классом ). Класс, от которого подкласс (subclass) наследуется называется суперклассом (superclass) (также базовым классом или родительским классом).  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html  

2. Какой класс является родительским для всех классов?  
**Ответ.**   
Класс Object, определенный в ``java.lang`` пакете, определяет и реализует поведение, общее для всех классов, включая написанные нами. В платформе Java многие классы являются производными непосредственно от ``Object``, другие классы являются производными от некоторых из этих классов и так далее, образуя иерархию классов.  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html  
 
3. Какой класс является родительским для всех перечислений?
**Ответ.**   
Все перечисления косвенным образом наследуют ``java.lang.Enum``.  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html 
 
4. Какой интерфейс является родительским для всех интерфейсов?  
**Ответ.**  
Интерфейсы, в отличии от классов не имеют родительского интерфейса.  
**Источник.**   -
 
5. Сформулируйте критерий отношения наследования между двумя сущности физического мира.   
Другими словами, какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?  
**Ответ.**    
Наследование описывает связь «является» (is a);  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html 

6. Есть ли отношение наследования между сущностями:
а) квадрат и прямоугольник;  
б) сосна и доска;  
в) книга и страница?  
Поясните ответ.   
**Ответ.**   
а) нет;  
б) нет;  
в) нет.  
К данным примерам не подходит отношение «является».  
а) – прямоугольник состоит из квадратов;  
б) – доска состоит из сосны;  
в) – книга состоит из страниц.  
**Источник.**   -

7. В чем смысл конструкции ``super``?  
Перечислите случаи, когда используется конструкция ``super``.  
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими  
возможностями. Если можно, то каким образом?  
**Ответ.**   
``super()``- вызывается конструктор суперкласса без аргументов.  
``super(parameter list)``- вызывается конструктор суперкласса с соответствующим списком параметров.  
``super.`` - для вызова метода суперкласса, а также для обращения к полю супер класса.  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/IandI/super.html 

8. Можно ли одновременно использовать ``this()`` и ``super()`` в конструкторе?   
Поясните ответ.   
**Ответ.**   
Нет нельзя. Так как вызов конструктора суперкласса должен быть первой строкой в конструкторе подкласса и вызов другого конструктора этого же класса должен быть первой строкой в конструкторе. То использование ``this()`` и ``super()`` в одном и том же конструкторе недопустимо.  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/IandI/super.html 
https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html

9. Дан код.  
```java
class SomeClass() {
	...
	public SomeClass() {
		doSmth();
	}
	protected void doSmth() {
		...
	}
}
```
Это потенциальный антипаттерн. Почему?  
**Ответ.**   
Метод doSmth объявлен ``protected`` (для возможности его вызова только из того же пакета и из классов наследников). В публичном методе SomeClass происходит метод вызова doSmth, следовательно метод doSmth может быть вызван из любого класса, несмотря на то, что он ``protected``.  
**Источник.**   -

10. Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?  
**Ответ.**    
Класс может реализовать не все методы интерфеса. Если класс не реализует какие-то методы интерфейса, то такой класс должен быть определен как абстрактный, а его неабстрактные классы-наследники затем должны будут реализовать эти методы.  
**Источник.**   https://metanit.com/java/tutorial/3.7.php 

11. Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?  
**Ответ.**   
Интерфейсы без каких-либо методов действуют как маркеры. Они лишь говорят компилятору, что объекты классов, которые имплементят такой интерфейс без методов, должен иметь отличительные черты, восприниматься по-другому. Маркерные интерфейсы также известных как "теги", поскольку они добавляют общий тег ко всем унаследованым классам, объединяя их в одну категорию.  
**Источник.**   https://sites.google.com/site/progerbingbang/voprosy-na-sobesedovanii/zacemnuznyinterfejsybezmetodov 

12. Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?  
**Ответ.**   
Переопределение метода выполняется только в том случае, если сигнатуры методов одинаковы, в одном классе нельзя определить 2 метода с одинаковыми сигнатурами, значит переопределение метода в одном классе невозможно.   
При перегрузке методы должны иметь различные сигнатуры, при этом имя метода должно совпадать. Перегрузить метод в одном классе можно.  
**Источник.**   https://java-course.ru/begin/override-overload/ 

13. Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?  
**Ответ.**   
Метод можно переопределить в подклассе.   
Если два метода класса (объявлены оба в одном классе или оба унаследованы классом, или один объявлен и один унаследован) имеют одно и то же имя, но сигнатуры, которые не эквивалентны переопределению, тогда методы будет перегружен.  
**Источник.**   
https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.9 

14. Можно ли переопределить статический метод? Поясните ответ.  
**Ответ.**   
Если подкласс определяет статический метод с той же сигнатурой, что и статический метод в суперклассе, то метод в подклассе скрывает метод в суперклассе.  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/IandI/override.html 

15. Как запретить переопределение метода в подклассе? Назовите 2 способа.  
**Ответ.**   
1) Чтобы запретить переопределение метода, в начале его объявления следует указать ключевое слово ``final``.  
2) использовать у метода модификатор доступа ``private``.   
**Источник.**   https://pro-java.ru/java-dlya-opytnyx/predotvrashhenie-pereopredeleniya-s-pomoshhyu-klyuchevogo-slova-final-v-java/#:~:text=%D0%A7%D1%82%D0%BE%D0%B1%D1%8B%20%D0%B7%D0%B0%D0%BF%D1%80%D0%B5%D1%82%D0%B8%D1%82%D1%8C%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%2C%20%D0%B2,%D0%B2%20%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%BD%D0%BE%D0%BC%20%D0%BD%D0%B8%D0%B6%D0%B5%20%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B5%20%D0%BA%D0%BE%D0%B4%D0%B0.&text=void%20niceMethod()%20%7B%20%2F%2F%20%D0%9E%D1%88%D0%B8%D0%B1%D0%BA%D0%B0! 

16. С помощью какого механизма реализуется полиморфизм в Java?  
**Ответ.**   
Полиморфизм реализуется при помощи переопределения и перегрузки методов.  
**Источник.**   
И.С.Блинов, В.Н.Романчик «Java Методы программирования», с. 97  

17. Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?  
**Ответ.**   
Утверждение верно. Присвоить ссылке суперкласса ссылку объекта подкласса.  
**Источник.**   -

18. SmallEntity и BigEntity - это подклассы Entity.  
Можно ли отрефакторить данный код? Если да, то выполните.   
```java
class EntityFactory { 
public static Entity getEntity(int num) {
		switch(num) {
			case 2: return new Entity();
			case 3: return new SmallEntity();
			case 4: return new BigEntity();
			default: throw new IllegalArgumentException();
		}
}
}
```
**Ответ.**   
```java
class EntityFactory { 
private enum EntityKind{
		ENTITY{
		    Entity getEntity(int num){
			    return new Entity(num);
		}
	},		
           SMALL_ENTITY{
		    SmallEntity getEntity(int num){
			     return new SmallEntity(num);
		}
	},
           BIG_ENTITY{
		    BigEntity getEntity(int num){
			     return new BigEntity (num);
		}
	};
		abstract Entity getEntity(int num); 
}
  ```
**Источник.**   -

19. Можно ли отрефакторить данный код? Если да, то выполните.  
```java  
class Entity { 
	...
	private String action;
	public void doSmth() {
		switch(action) {
			case "sing-solo": singSolo(); break;
			case "sing-duet": singDuet(); break;
			case "dance": dance();
		}
	}
	private void singSolo() {
		...
	}
	private void singDuet() {
		...
	}
	private void dance() {
		...
	}
}
```
**Ответ.**   
**Источник.**   

20. Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?  
Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:  
1) b = i; ?  
2) i = b; ?  
**Ответ.**   
а) Можно создать объект класса B по ссылке а.  
б) Ссылке типа интерфейса можно присвоить объект, реализующий данный интерфейс.  
b  =  i – нельзя;  
i = b – можно.   
**Источник.**   http://easy-code.ru/lesson/java-interfaces 

21. В чем заключается отличие сравнения принадлежности к классу через операцию ``instanceof`` и метод ``getClass()``?  
**Ответ.**   
instanceof проверяет, является ли ссылка на объект с левой стороны (LHS) экземпляром типа с правой стороны (RHS) или некоторым подтипом .  
``getClass() ==`` ... проверяет идентичность типов.  
``getClass() ==``  возвращает true только в том, случае, если объекты имеют одинаковый класс, а ``instanceof`` возвращает ``true`` еще в том случае, когда класс является наследником класса.  
**Источник.**   https://question-it.com/questions/4902769/instanceof-protiv-getclass 

22. Можно ли создать:  
1) ссылку на объект абстрактного класса?  
2) объект абстрактного класса?  
3) ссылку на интерфейс?  
4) объект типа интерфейс?  
**Ответ.**   
1- Можно.  
2- Нет. Объект абстрактного класса создать нельзя.  
3- Нельзя.  
4- Можно, при этом класс объекта должен реализовывать данный интерфейс.  
**Источник.**   -

23. Может ли класс:  
1) реализовывать два интерфейса?  
2) расширять два класса?  
3) расширять два интерфейса?  
4) расширять один класс и реализовывать один интерфейс?  
5) расширять сам себя?  
**Ответ.**   
1- Может.  
2- Нет.  
3- Нет.  
4- Может.  
5- Нет.  
**Источник.**   -

24. Для каких целей используется расширение интерфейса?  
**Ответ.**   
Интерфейс может наследоваться от другого интерфейса через ключевое слово extends. Один интерфейс, в отличие от классов, может расширять несколько интерфейсов.  
Используется для сокращения написанного кода.  
**Источник.**   https://www.examclouds.com/ru/java/java-core-russian/interfaces#header3 

25. Могут ли в интерфейсе быть поля?  
**Ответ.**   
Интерфейс может содержать поля, но они автоматически являются статическими (``static``) и неизменными (``final``)  
**Источник.**   http://developer.alexanderklimov.ru/android/java/interface.php 

26. Можно ли в интерфейсе  
1) объявить метод с пакетным уровнем доступа?  
2) объявить конструктор?  
3) определить конструктор?  
**Ответ.**   
1- Нет. Все методы и переменные неявно объявляются как ``public``.  
2- Нет. В интерфейсе не содержатся конструкторы.  
3- Нет.   
4- Нет  
**Источник.**   http://developer.alexanderklimov.ru/android/java/interface.php 
http://proglang.su/java/interfaces#:~:text=%D0%9E%D1%82%D0%BB%D0%B8%D1%87%D0%B8%D0%B5%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B0%20%D0%BE%D1%82%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20%D0%B2,%D0%92%20%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%B5%20%D0%BD%D0%B5%20%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D1%82%D1%81%D1%8F%20%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D1%8B. 

27. Можно ли интерфейс объявить финальным? Поясните ответ.    
**Ответ.**   
Нельзя. Если бы интерфейс был final, то никакой другой интерфейс не смог бы его расширить, также ни один класс не смог бы реализовать интерфейс.  
**Источник.**   https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.1.1

28. Можно ли в интерфейсе объявить статический метод? Поясните ответ.   
**Ответ.**    
В интерфейсе можно объявлять статические методы, которые вызываются без ссылки на конкретный объект.  
**Источник.**    https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.1.1 

29. Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.    
**Ответ.**   
Можно.  
**Источник.**   -

30. Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?  
**Ответ.**   
Нельзя создать объект или экземпляр абстрактного класса  
**Источник.**   https://metanit.com/java/tutorial/3.6.php#:~:text=%D0%92%20%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%BC%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B5%20%D1%82%D0%B0%D0%BA%D0%B6%D0%B5%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE,%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%20%D0%B8%D0%BB%D0%B8%20%D1%8D%D0%BA%D0%B7%D0%B5%D0%BC%D0%BF%D0%BB%D1%8F%D1%80%20%D0%B0%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0. 

31. Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?  
**Ответ.**   
Не должен.  
Мы должны унаследовать класс от этого абстрактного класса, например: цель класса HttpServlet заключается в том, что если вы не реализуете свою логику в дочернем классе, вы можете получить родительскую логику  
**Источник.**   https://qastack.ru/programming/4811678/defining-an-abstract-class-without-any-abstract-methods 

32. Что означает ключевое слово final в следующих конструкциях?  
1)
```java  
public final class SomeClass() { }
```
2)
```java
public class SomeClass() {
public final void doSmth();
}
```
**Ответ.**   
1) От класса SomeClass нельзя наследоваться.  
2) Метод doSmth не может быть переопределен в классах наследниках.  
**Источник.**   -

33. Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.   
**Ответ.**   
Абстрактный метод должен переопределиться в классе наследнике, а в случае применения модификатора ``final``, метод не может быть переопределен и теряется смысл объявления метода.  
**Источник.**   -

34. К каким методам неприменимы принципы позднего связывания? Почему?  
**Ответ.**   
Принципы позднего связывания неприменимы к статическим методам, потому что связывание статических методов происходит рано, во время компиляции.  
**Источник.**   https://javarush.ru/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java 

35. В чем заключается отличие между ранним и поздним связыванием?  
**Ответ.**   
Отличие состоит в том, что первое происходит рано, во время компиляции на основе типа ссылочной переменной, а второе – позднее, во время выполнения, с использованием конкретных объектов.  
**Источник.**   https://javarush.ru/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java 

36. Бонусное задание 1 (необязательное)  
Добавить к задаче inheritance2 пункт:  
8) Найти в отсортированном массиве ВСЕ покупки со стоимостью 5.00 BYN, для первоначального поиска использовав метод Arrays.binarySearch( ).  
Желательно найти такое решение, которое после поиска позволяет выполнить задачу за один цикл.  
Трюки типа Arrays.copyOfRange() не засчитываются, т.к. они реализованы через цикл.  
То есть если быть максимально точным, то должен быть один цикл, и вычислительная сложность алгоритма после вызова метода Arrays.binarySearch( ) должна быть равна O(n).   
Подсказка 1 - это решение существует )  
Подсказка 2  
----------------- см. следующую строку -------------  
В чем смысл отрицательного значения метода binarySearch()?  
---------------------------------------------------------------  

