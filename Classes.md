1.	Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?  
**Ответ.**   
Для класса, не являющегося вложенным, может быть указан только один из двух возможных уровней доступа: заданный по умолчанию и ``public``. Когда класс объявлен как ``public``, он должен быть единственным ``public`` классом, объявленным в файле, и имя файла должно совпадать с именем класса.  
**Источник.** http://pr0java.blogspot.com/2015/07/1.html 

2. Что является членами класса?  
**Ответ.**   
Класс содержит переменные и методы, которые называются элементами класса, членами класса.  
**Источник.** http://surl.li/beknn

3. Что еще можно определить в классе кроме членов?  
**Ответ.**   Кроме обычных методов классы могут определять специальные методы, которые называются конструкторами. Конструкторы вызываются при создании нового объекта данного класса. Конструкторы выполняют инициализацию объекта.  
**Источник.** https://metanit.com/java/tutorial/3.1.php 

4. Какие уровни доступа есть у членов класса?  
**Ответ.**   
``public`` – любой компонент, объявленный как ``public``, доступен из любого кода  
``protected`` – разрешает доступ к компоненту в пределах пакета и классам наследникам   
``private`` – разрешает доступ к компоненты в пределах класса  
по умолчанию (нет ключевого слова) – разрешает доступ к компонентам в пределах пакета  
**Источник.** http://pr0java.blogspot.com/2015/07/1.html 
 
5. Какие модификаторы необходимы для определения константы:  
1) класса,  
2) экземпляра класса?  
**Ответ.**   
Для определения константы класса необходимы модификаторы ``static final``.  
Для определения константы экземпляра класса необходим модификатор final.  
**Источник.** https://javarush.ru/quests/lectures/questsyntaxpro.level06.lecture05 

6. Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:    
```java
  class SomeClass {
	private int a;
	private final int b;
  private static int c;
  private static final int D;
...
}
```
Как можно назвать данные поля в зависимости от комбинации модификаторов ``static`` и ``final``?  
**Ответ.**  
``private int a`` – поле экземпляра класса;  
``private final int b`` – константа экземпляра класса;  
``private static int c`` – статическая переменная класса;  
``private static final int D`` – константа класса;  
**Источник.**  https://javarush.ru/quests/lectures/questsyntaxpro.level06.lecture05 

7. Может ли класс не иметь ни одного конструктора? Почему?  
**Ответ.**    
Если в классе не объявить ни одного конструктора, то, будет генерироваться конструктор по умолчанию. Конструктор по умолчанию генерируется в классе автоматически только в том случае, если класс не содержит реализации других конструкторов.  
**Источник.** http://surl.li/bekol  
 
8. Перечислите отличия конструктора от метода.  
**Ответ.**   
Конструктор - это специальный метод, который вызывается при создании нового объекта.  
Конструктор создает экземпляр класса, метод группирует операторы  
Конструктор не может быть ``abstract``, ``final``, ``native``, ``static``, или ``synchronized``, а метод может.  
У конструктора нет возвращаемого типа, не может быть даже ``void``, а метод может возвращать любой тип или быть ``void``.  
Имя конструктора такое же как и имя класса (по договоренности, первая буква — заглавная) — обычно существительное, а у метода может быть Любое имя, за исключением имени класса. Имена методов начинаются со строчной буквы, по договоренности, и обычно являются глагол.  
Конструкторы не наследуются, а методы наследуются.  
Если в классе не описан конструктор, компилятор автоматически добавляет в код конструктор без параметров, а метод отсутствует.  
**Источник.** http://www.javable.com/javaworld/10_00/01/ 

9. Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?  
**Ответ.**   
Для этого используется ключевое слово ``this``, после которого в круглых скобках указываем параметры для соответствующего конструктора.  
Можно вызвать один конструктор из другого в том же классе, или в надклассе, со следующими ограничениями:   
Вызываемый конструктор должен быть в первой строке кода в вызывающем конструкторе.  
Вложенный конструктор не может иметь никакой явной или неявной ссылки на ``"this"``.   
**Источник.**  https://javarush.ru/groups/posts/793-vihzov-konstruktora-iz-konstruktora 
 
10. Как и в каком месте можно вызвать конструктор суперкласса?  
**Ответ.** 
Конструктор суперкласса (базового класса) может быть вызван из подкласса (производного класса). Этот вызов осуществляется с помощью ключевого слова ``super``. Вызов конструктора суперкласса должен быть осуществлен в теле конструктора подкласса первым.  
Общая форма вызова конструктора суперкласса из конструктора подкласса следующая:  
``super(parameters)``;  
parameters – перечень параметров, которые получает конструктор. Если конструктор не имеет параметров, то конструктор суперкласса вызывается как ``super()``.  
**Источник.**  http://surl.li/bekpy 

11. Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?  
**Ответ.**   
Если в методе построения подкласса нет явного определения ``super()`` или ``super(фактического параметра)``, оно будет предоставлено по умолчанию.  
**Источник.** https://russianblogs.com/article/28691101978/ 

12. Можно ли одновременно использовать конструкции ``this()`` и ``super()`` в одном и том же конструкторе?  
Обоснуйте ответ.  
**Ответ.** 
Внутри конструктора ``this`` и ``super`` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и ``this()``, и ``super()``.  
Есть вероятность столкнуться с проблемой, при которой конструктор родительского класса) мог бы вызываться с разными параметрами, и появится как-то решить, какой из них следует использовать.  
**Источник.** https://blog-house.pro/java-interviews-questions/post-63205/   
https://clck.ru/ampWq

13. Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?  
**Ответ.**   
Иногда класс создаётся только для хранения каких-то статических полей и статических методов. Таким классам принято давать имена Utils, но это не обязательно. Такому классу не нужен конструктор, но если автор класса его не создал, то система сама создаст конструктор по умолчанию. Такой конструктор не имеет смысла, а также может послужить источником ошибок. Чтобы предохраниться от подобной проблемы мы сами явно должны создать пустой конструктор и сделать его закрытым.  
**Источник.** http://developer.alexanderklimov.ru/android/java/constructor.php 

14. Какие модификаторы может иметь конструктор?  
**Ответ.**  
В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: ``public``, ``protected``, ``private`` или без модификатора.  
**Источник.** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15 

15. Конструктор принадлежит классу или экземпляру класса?  
**Ответ.**   
Конструктор принадлежит классу.  
**Источник.** https://javarush.ru/groups/posts/1949-znakomstvo-s-klassami-napisanie-sobstvennihkh-klassov-konstruktorih 

16. Можно ли наследовать конструктор?  
Если да, то приведите примеры.   
**Ответ.** 
Конструкторы не наследуются.  
**Источник.** http://www.javable.com/javaworld/10_00/01/ 

17. Какой тип возвращаемого конструктором значения?  
**Ответ.**   
Конструкторы не имеют возвращаемого типа. Это объясняется тем, что неявно заданным возвращаемым типом конструктора класса является тип самого класса.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/konstruktori 

18. Дан класс.  
```java
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
	//фрагмент 2
	Null() {
		return null;
	}
}
```
В каком фрагменте ошибка компиляции?   
Удалите этот фрагмент полностью.   
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.   
**Ответ.** 
```java
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
}
```
Оставшийся фрагмент это метод ``Null()``, который возвращает значение «``null``» типа ``Null``.  
Демонстрация функционала:  
```java
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
public static void main(String[] args) {
    Null nullMethod = new Null();
    System.out.println(nullMethod.Null());
}
}
```
**Источник.** -

19. Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?  
**Ответ.** 
По отсутствующему заданному явно типу возвращаемого значения транслятор определяет конструктор.  
**Источник.** -

20. Дан класс.  
```java
class Name {
	String name;
	Name() {
		this(makeRandomName());
	}
	Name(String name) {
		super();
		this.name = name;
	}
	String makeRandomName() {
		int k = (int) (Math.random() * 3);
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
		return name;
	}
	public String toString() {
		return name;
	}
	public static void main(String[] args) {
		System.out.println(new Name());
	}
}
```
Объясните причину ошибки компиляции.  
Предложите минимум 2 способа исправления ошибки, использовать метод ``makeRandomName()`` обязательно.  
**Ответ.**  
```java
// 1 способ
class Name {
        String name;
        Name() {
            name = makeRandomName();
        }
        Name(String name) {
            super();
            this.name = name;
        }
        String makeRandomName() {
            int k = (int) (Math.random() * 3);
            String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
            return name;
        }
        public String toString() {
            return name;
        }
        public static void main(String[] args) {
            System.out.println(new Name());
        }
```
```java
// 2 способ
…
```
**Источник.** -

21. Дан класс.  
```java
class Int {
	int i;
	void inc(Int param) {
		//param = new Int();
		param.i++;
	}
	public static void main(String[] args) {
		Int obj = new Int();
		obj.inc(obj);
		System.out.println(obj.i);
	}
}
```
Изменится ли результат, если убрать комментарий?  
Объясните, почему?  
**Ответ.**  Результат не изменится, потому что Комментарии игнорируются при выполнении программы.  
**Источник.** -

22. В чем смысл конструкции ``this``?  
Перечислите случаи, когда используется конструкция ``this``.  
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?  
**Ответ.**   
Как правило, применять ``this`` нужно в двух случаях:  
1)	Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена;  
2)	Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого. Это еще называется явным вызовом конструктора.  
Без конструкции ``this`` можно обойтись в следующем примере, Когда имена принимаемых параметров отличаются от имен полей класса.  
```java
Box(double w, double h, double d) {
     width = w;
     height = h;
     depth = d;
}
```
**Источник.** https://javarush.ru/groups/posts/608-kljuchevoe-slovo-this-v-primerakh 

23. Можно ли присвоить ``null`` ссылочной переменной ``this``?  
**Ответ.**  
**Источник.** 

24. Перечислите случаи, когда используется статический блок?  
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** 
Статический блок используется для инициализации статических переменных.  
Статический блок выполняется до вызова конструктора.  
**Источник.**  https://clck.ru/ams4D 

25. Перечислите случаи, когда используется логический блок?  
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.**  
Логические блоки чаще всего используются в качестве инициализаторов полей, но могут содержать вызовы методов и обращения к полям текущего класса.  
Логический блок выполняется до вызова конструктора  
**Источник.** http://crypto.pp.ua/2010/06/logicheskie-bloki-java/

26. Что входит в сигнатуру метода?  
**Ответ.**  
Сигнатура метода — это имя метода плюс параметры (причем порядок параметров имеет значение).  
**Источник.** https://javarush.ru/groups/posts/1249-signatura-metoda 

27. Что значит ключевое слово ``native``?  
**Ответ.**   
Это означает, что метод реализован с использованием собственного кода, написанного на другом языке (например, C или C ++) через ``JNI`` (собственный интерфейс ``JAVA``).  
**Источник.** https://clck.ru/ampqt

28. Дан код.  
```java
public class BusinessTrip {
  …
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
```
Есть ли в нем семантическая ошибка?  
Если да, то обоснуйте.  
**Ответ.**  
**Источник.** 

29. Дан код.  
```java
public class Utility {
  private Utility() {
  }
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
```
Есть ли в нем семантическая ошибка?  
Если да, то предложите альтернативные варианты.   
**Ответ.**   
**Источник.** 

30. К каким данным можно обратиться в статическом методе?  
**Ответ.**  
В статическом методе можно обратиться только к статическим переменным/методам.  
**Источник.** https://javarush.ru/groups/posts/modifikator-static-java 

31. Почему нельзя объявить статическое поле внутри метода?  
**Ответ.**  
**Источник.** 

32. Перечислите, какой код в классе можно выполнить до создания объекта.  
**Ответ.**   
Код, заключенный в статический блок  
Код инициализации статических переменных класса  
**Источник.** https://javarush.ru/groups/posts/2137-porjadok-deystviy-pri-sozdanii-obhhekta 
 
33. В чем различие между объектом и экземпляром класса?  
**Ответ.**  
Термины «экземпляр класса» и «объект» взаимозаменяемы  
**Источник.** https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) 

34. Назовите три этапа создания экземпляра класса.  
**Ответ.** 
Создание объекта состоит из трёх этапов:  
Декларация  
Декларирование переменной типа класса с уникальным именем.  
Инстанциация  
Создание нового объекта с использованием ключевого слова ‘``new``’.  
Инициализация  
Вызов конструкторов, который идёт после ключевого слова ‘``new``’.  
**Источник.** https://proselyte.net/tutorials/java-core/classes-and-objects/ 

35. Охарактеризуйте отношение композиции между классами? Как оно реализуется?  
**Ответ.**   
В основе лежит тип отношения «является частью» («HAS A»).  
Например, класс автомобиля содержит объект класса электрического двигателя. При уничтожении объекта автомобиля в области памяти вместе с ним будет уничтожен и объект двигателя. И в этом плане объект автомобиля является главным, а объект двигателя - зависимой.  
**Источник.** https://metanit.com/sharp/patterns/1.2.php 
 
36. Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.  
Предложите способы и подтвердите примерами.  
**Ответ.**   
Создать свой собственный объект для хранения значений, чтобы сохранить оба значения, а затем вернуть его:  
``return new objectWithTwoValues(int a, int b);`` 
Вернуть массив.
``return new int[] {int a, int b};`` 
**Источник.** -

37. Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.  
Предложите способы и подтвердите примерами.  
**Ответ.** 
Создать свой собственный объект для хранения значений, чтобы сохранить оба значения, а затем вернуть его:  
``return new objectWithTwoValues(int a, char b); ``
**Источник.** - 

38. Что такое иммутабельный объект?   
Опишите 2 способа создания иммутабельных объектов.   
Подсказка. Способ 1 - класс материала в ``classes2``.  
Какой альтернативный?  
Подсказка - ключевое слово final для полей не использовать.  
Создайте иммутабельный класс для вещества по альтернативному способу.   
**Ответ.**   
``Immutable`` объекты(с англ. "неизменяемый") - это объект, который не позволяет изменять свои параметры. А если Вы все-же пытаемся что-то изменить, то получаем новый объект. Но старый останется прежним.  
1 Способ.  
1) Сделать все поля финальными;  
2) Все поля класса должны быть приватными в соответствии с принципами инкапсуляции.  
3) Для исключения возможности изменения состояния после инстанцирования, в классе не должно быть сеттеров.  
2 Способ.  
…  
**Источник.** -

39. Даны 2 класса.  
```java
final class Material {
	private final String name;
	private final double density;
	...
}
class Runner {
	private static void printMaterial(final Material material) {
        	System.out.println(material);
	}
	public static void main(String[] args) {
        	Material steel = new Material("steel",7850);
        	printMaterial(steel);
	}
}
```
В методе ``printMaterial()`` по ссылке ``material`` создается новый объект или имеется доступ к объекту ``new Material("steel",7850)``?  
Какой пример можно использовать для обоснования ответа?  
**Ответ.**  
**Источник.** 

40. Класс для комплексного числа содержит два поля:  
```java
class Complex {
	private double re;
	private double im;
	…
}
```
Реализуйте в данном классе методы: ``plus()`` для операции ``+`` и ``add()`` для ``+=``.  
Приведите пример использования каждого метода.  
Реализуйте эти же методы при условии, что класс Complex является иммутабельным.   
**Ответ.**  
**Источник.** 

41. Для чего предназначен метод ``toString()``?  
В каких случаях он вызывается?  
**Ответ.**   
``toString`` метод в ``Java`` используется для предоставления ясной и достаточной информации об объекта (``Object``) в удобном для человека виде.  
Для вызова метода ``toString()`` необходимо просто передать нужный объект в ``System.out.println``:  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/method-tostring 

42. Как реализован метод ``toString()`` в классе ``Object``?  
**Ответ.**   
```java
getClass().getName() + '@' + Integer.toHexString(hashCode())
  ```
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#toString()

43. Для чего предназначен метод ``equals()``?  
В каких случаях он вызывается?  
**Ответ.**   Предназначен для сравнения объектов.   
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object) 

44. Как реализован метод ``equals()`` в классе ``Object``?  
**Ответ.**  
```java
public boolean equals(Object obj) {
    return (this == obj);
}
```
**Источник.**  https://javarush.ru/groups/posts/1340-peregruzka-metodov-equals-i-hashcode-v-java 

45. В чем различие между методом ``equals()`` и операции ``==``?  
В каких случаях применение метода ``equals()`` и операции ``==`` эквивалентно?  
**Ответ.**   
``==`` используется для сравнения ссылок объектов, т.е. оба объекта указывают на одну и ту же ячейку памяти.  
``.equals()`` выполняет сравнение значений в объектах.  
применение метода ``equals()`` и операции ``==`` эквивалентно в случае, когда метод ``.equals()`` не переопределен, а используется его реализация из класса ``Object``.  
**Источник.** https://qastack.ru/programming/7520432/what-is-the-difference-between-and-equals-in-java 

46. Eclipse в стандартной конфигурации генерирует начало метода ``equals()`` следующим образом:  
  ```java  
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
  ```  
С чем связаны данные проверки, которые кажутся лишними?  
**Ответ.**  
``if (this == obj)`` - проверка на то, не сравнивается ли объект сам с собой (в случае, когда это один и тот же объект, возвращается ``true``)  
``if (obj == null)`` - проверка на то, не является объект, с которым производится сравнение – ``null`` (в случае сравнения объекта с ``null``, возвращается ``false``).  
**Источник.** - 
 
47. Что такое garbage collection?  
**Ответ.** 
Это одна из форм автоматического управления памятью. Специальный процесс, называемый сборщиком мусора (англ. garbage collector), периодически освобождает память, удаляя объекты, которые уже не будут востребованы приложениями.  
**Источник.** https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0 

48. Перечислите случаи, когда JVM отдает управление на garbage collector.  
**Ответ.**  
Если переменная ссылочного типа, которая ссылается на объект, установлена в положение "0", объект подлежит утилизации, в том случае, если на него нет других ссылок.  
Если переменная ссылочного типа, которая ссылается на объект, создана для ссылки на другой объект, объект подлежит утилизации, в том случае, если на него нет других ссылок.  
Объекты, созданные локально в методе, подлежат утилизации, когда метод завершает работу, если только они не экспортируются из этого метода (т.е, возвращаются или генерируются как исключение).  
Объекты, которые ссылаются друг на друга, могут подлежать утилизации, если ни один из них не доступен живому потоку.  
**Источник.**  https://javarush.ru/groups/posts/917-sborka-musora 

49. Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?  
**Ответ.**   
Возможен запрос на запуск сборщика мусора, но невозможно принудительно задавать это действие. Для этого необходимо запустить один из двух методов:
```java
System.gc();
Runtime.getRuntime().gc();
```
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora 

50. Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти?  
Обоснуйте ответ.  
**Ответ.**  
JVM обычно запускает сборщик мусора при низком уровне свободной памяти. Но работа сборщика мусора не гарантирует, что всегда будет оставаться достаточно свободной памяти. Если памяти недостаточно даже после восстановления, JVM генерирует исключение OutOfMemoryError. Перед генерированием исключения JVM обязательно запускает сборщик мусора как минимум 1 раз.  
**Источник.**  https://javarush.ru/groups/posts/917-sborka-musora 

51. Для чего предназначен метод ``finalize()``?  
Какой недостаток у метода?  
**Ответ.**  
Чтобы произвести необходимую очистку перед тем, как сборщик мусора извлекает объект из памяти. Этот метод вызывается для объекта сборщиком мусора, когда сборщик мусора вычисляет, что ссылок к объекту больше нет.  
Недостатки:  
Первая заметная проблема-отсутствие оперативности. Мы не можем знать, когда запускается финализатор, так как сбор мусора может произойти в любое время. Могут закончиться ресурсы до того, как произойдет очистка, что может привести к сбою системы.  
Стоимость производительности - еще одна существенная проблема, связанная с финализаторами. В частности, JVM должна выполнять гораздо больше операций при создании и уничтожении объектов, содержащих непустой финализатор.  
отсутствие обработки исключений во время завершения. Если финализатор создает исключение, процесс завершения останавливается, оставляя объект в поврежденном состоянии без какого-либо уведомления.  
**Источник.** https://javascopes.com/java-finalize-d768312e/ 

52. Для чего предназначены оболочечные классы?  
Как они называются на инглише?  
**Ответ.**  
Оболочка — это специальный класс, который хранит внутри себя значение примитива. Оболочки хранят внутри нужные значения примитивов, при этом будут являться настоящими объектами.  
Предназначены для того, чтобы была возможность работать с примитивными типами как с объектами. (например использование в коллекциях).  
К оболочкам типов относятся классы ``Double``, ``Float``, ``Long``, ``Integer``, ``Short``, ``Byte``, ``Character``, ``Boolean``, ``Void``.  
**Источник.** https://javarush.ru/groups/posts/1948-objertki-raspakovka-i-zapakovka 

53. В чем преимущество примитивных типов перед соответствующими оболочечными классами?   
**Ответ.**   
Преимущество примитивных типов в скорости работы.  
**Источник.** https://javarush.ru/groups/posts/1948-objertki-raspakovka-i-zapakovka 

54. Что такое autoboxing и unboxing?  
**Ответ.**  
Autobixing (автоупаковка) – возможность присвоения переменной класса-оболочки значения примитивного типа.  
Unboxing (распаковка) – возможность присвоения переменной примитивного типа объекта класса-оболочки.  
**Источник.** https://javarush.ru/groups/posts/1948-objertki-raspakovka-i-zapakovka 

55. Дан код:  
```java
Integer a = 3, b =7;
Long c = a + b;
```
Перечислите все операции, где задействованы autoboxing и unboxing.  
**Ответ.**  
Integer a = (autoboxing)3, b = (autoboxing) 7;    
(autoboxing) Long c = (unboxing)a + (unboxing)b;   
**Источник.** -

56. Дан корректный раннер-класс.  
Будет ли ошибка компиляции, если удалить модификатор ``static`` из сигнатуры метода ``main()``?   
Обоснуйте ответ.  
Что произойдет, если отправить на выполнение измененный класс?  
**Ответ.**  
Ошибки компиляции не возникнет. Без модификатора ``static`` этот метод не будет являться точкой входа в программу, поскольку JVM не знает, как создать объект класса, но как метод класса он может существовать.  
Если отправить его на выполнение, то программа не запустится, JVM не знает, как создать объект класса, поэтому ему нужен стандартный способ доступа к основному методу, который возможен, объявив ``main()`` как ``static``.  
**Источник.** https://overcoder.net/q/1248385/%D1%87%D1%82%D0%BE-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-public-static-void-main-args 

57. Дан класс.  
```java
class Runner {
	public static void main(String[] args) {
        	System.out.println("Hello, world!");
	}
}
```
Запрещается изменять синий код, т.е. метод ``main()``.  
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:  
I am java.
Hello, world!
**Ответ.**  
```java
class Runner {
    static {
        System.out.println("I am java.");
    }
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```
**Источник.** -

58. Бонусное задание 1 (необязательное)  
В задаче classes3 имеются два константных поля в классе покупки.  
Им сразу присваиваются значения по умолчанию.  
Например.  
```java
public class Purchase {
  public final static String PRODUCT_NAME = "milk";
  public final static int PRICE = 120;
  ...
}
```
Измените реализацию так, чтобы константы инициализировались значениями из текстового файла, находящемся в том же пакете, что и класс покупки. Имя файла - константа в классе покупки.  
Если будет сбой с файлом или в нем будут недопустимые значения, то присвойте константам ``PRODUCT_NAME`` и ``PRICE`` значения по умолчанию.  
Для этого же примера начало класса должно быть таким:  
```java
public class Purchase {
  private static final String PRODUCT_NAME;
  private static final int PRICE;
  public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
  private static final String DEFAULT_PRODUCT_NAME = "milk";
  private static final int DEFAULT_PRICE = 120;
  ```
**Ответ.**  
**Источник.** 
