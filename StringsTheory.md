Вопрос 1.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String a = "java";
a.toUpperCase();
System.out.println(a);
```
**Ответ.**   
java  
**Источник.**  

Вопрос 2.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");
System.out.println("s1 == s2 : " + (s1 == s2));
System.out.println("s1 == s3 : " + (s1 == s3));
System.out.println(s1.equals(s3));
```
Поясните ответ.  
**Ответ.**  
```java
s1 == s2 : true
s1 == s3 : false
true
```
1) Оператор == сравнивает не свойства объектов, а ссылки.  
В первой и второй строке, при создании объекта типа ``String``, объект создается в пуле строк. При создании во второй строке объекта s2, java проверяет пул и если там присутствует такая строка, то ссылка будет указывать на тот же адрес в пуле строк, где эта строка хранится. Следовательно у s1 и s2 одинаковые ссылки, значит  (``s1 == s2 : true``).  
2) Оператор new при создании объекта принудительно выделяет для него новую область в памяти. И строка, созданная с помощью new, не попадает в String Pool: она становится отдельным объектом, даже если ее текст полностью совпадает с такой же строкой из String Pool. Следовательно и ссылки у объектов разные, поэтому ``s1 == s3 : false``.  
3) У класса ``String`` есть переопределенный метод equals(), который сравнивает не ссылки, а содержимое строк, следовательно ``s1.equals(s3)`` дает true, так как содержимое строк одинаково.  
**Источник.**   https://javarush.ru/groups/posts/equals-java-sravnenie-strok 

Вопрос 3.  
Можно ли выполнить наследование от класса ``String``?   
Почему?  
**Ответ.**  
Нет, класс ``String`` объявлен ``final``.  
**Источник.**   https://proghub.ru/q/8b7bbe 

Вопрос 4.  
Назовите основные, на ваш взгляд, методы класса ``String``.    
**Ответ.**  
•	``concat()``: объединяет строки  
•	``valueOf()``: преобразует объект в строковый вид  
•	``join()``: соединяет строки с учетом разделителя  
•	``сompareTo()``: сравнивает две строки  
•	``charAt()``: возвращает символ строки по индексу  
•	``getChars()``: возвращает группу символов  
•	``equals()``: сравнивает строки с учетом регистра  
•	``equalsIgnoreCase()``: сравнивает строки без учета регистра  
•	``regionMatches()``: сравнивает подстроки в строках  
•	``indexOf()``: находит индекс первого вхождения подстроки в строку  
•	``lastIndexOf()``: находит индекс последнего вхождения подстроки в строку  
•	``startsWith()``: определяет, начинается ли строка с подстроки  
•	``endsWith()``: определяет, заканчивается ли строка на определенную подстроку  
•	``replace()``: заменяет в строке одну подстроку на другую  
•	``trim()``: удаляет начальные и конечные пробелы  
•	``substring()``: возвращает подстроку, начиная с определенного индекса до конца или до определенного индекса  
•	``toLowerCase()``: переводит все символы строки в нижний регистр  
•	``toUpperCase()``: переводит все символы строки в верхний регистр  
**Источник.**  https://metanit.com/java/tutorial/7.1.php 

Вопрос 5.  
Какие разновидности конструкторов использует класс String?  
**Ответ.**  
1) Конструктор, позволяющий создать строку, записав ее в двойных кавычках  
``String s1 =”java”``;
2) Конструктор, позволяющий создать строку через оператор new, передав в параметры строку.  
``String s2 = new String (“java”)``;
3) Конструктор, позволяющий создать строку через массив символов.  
```java
char[] chars = { 'j', 'a', 'v', 'a' };  
String s3 = new String(chars);  
```
4) Конструктор, позволяющий создать пустую строку.   
``String s4 = new String();``
5)  Конструктор, позволяющий задать диапазон символьного массива.   
```java
char[] chars = {'j', 'a', 'v', 'a', 'm', 'a', 'r', 'a', 'n' };
String str = new String(chars, 0, 3);
```
**Источник.**   http://developer.alexanderklimov.ru/android/java/string.php 

Вопрос 6.  
Какие классы в стандартной библиотеке Java работают со строками?  
**Ответ.**  
Реализация строк на Java представлена тремя основными классами: ``String``, ``StringBuffer``, ``StringBuilder``.  
**Источник.**   https://habr.com/ru/post/260767/ 

Вопрос 7.  
Почему экземпляры класса String в Java неизменные и финализированные?  
**Ответ.**  
1)	Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку  
2)	Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.  
3)	Так как строка неизменная, она безопасна для многопоточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности, строки полностью потокобезопасны.  
4)	Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных.  
5)	Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект в качестве ключа HashMap.  
**Источник.**   https://javastudy.ru/interview/strings/#:~:text=22.-,%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%20%D0%BD%D0%B5%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B8%20%D1%84%D0%B8%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B2%20Java%3F,%D0%BD%D0%B0%20%D0%BE%D0%B4%D0%BD%D1%83%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%83%D1%8E%20%D0%B2%20%D0%BF%D1%83%D0%BB%D0%B5. 

Вопрос 8.  
Заполните ячейки таблицы (Да/Нет).  
Characteristic 				String		StringBuilder		StringBuffer  
Неизменяемый (Immutable)?	  
Имеет пул (Pooled)?                          
Потокобезопасный (Thread-safe)?   
Может изменять размер?                 
**Ответ.**  
Characteristic 				                 String		          StringBuilder		            StringBuffer  
Неизменяемый (Immutable)?	               Да                  Нет                           Нет  
Имеет пул (Pooled)?                      Да                  Нет                           Нет  
Потокобезопасный (Thread-safe)?          Да                  Нет                           Да  
Может изменять размер?                   Нет                 Да                            Да  
**Источник.**   https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java 

Вопрос 9.  
В чем разница и что общего между StringBuffer и StringBuilder?  
**Ответ.**  
Общее то, что объекты двух классов изменяемы, а отличие в том, что класс StringBuilder не является потокобезопасным, а StringBuffer – потокобезопасен.   
**Источник.**   https://docs.oracle.com/javase/tutorial/java/data/buffers.html 

Вопрос 10.   
Когда лучше использовать StringBuffer, а когда StringBuilder?  
**Ответ.**  
Классы StringBuffer и StringBuilder используются в случаях, когда необходимо модифицировать строку. Класс StringBuffer лучше использовать в мультипоточной среде. В однопоточной среде лучше StringBuilder, так как он быстрее.  
**Источник.**   http://www.quizful.net/interview/java/string-stringbuffer-difference#:~:text=%D0%9A%D0%BB%D0%B0%D1%81%D1%81%20StringBuffer%20%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20mutable%20%2D%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C,%D1%87%D1%82%D0%BE%20%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5%D1%82%20%D0%B5%D0%B3%D0%BE%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%20%D1%88%D1%83%D1%81%D1%82%D1%80%D0%B5%D0%B5. 

Вопрос 11.  
Какие методы имеются в классах StringBuffer и StringBuilder, которые отсутствуют в классе String?  
**Ответ.**  
1) append() – добавляющий подстроку в существующий объект StringBuilder/StringBuffer.  
2) delete() – выполняющий удаление по индексу в объекте StringBuilder/StringBuffer  
3) insert() – выполняющий вставку элемента в объект StringBuilder/StringBuffer  
4) replace() – заменяющий элементы в объекте StringBuilder/StringBuffer  
5) setCharAt() – выполняющий вставку в объекта StringBuilder/StringBuffer  
6) reverse() – меняющий последовательность символов на обратную в объекте StringBuilder/StringBuffer  
7) toString() – возвращающий строку, которая содержит последовательность символов в объекте StringBuilder/StringBuffer  
8) setLength() – устанавливает длину строки.  
9) ensureCapacity() – выделяет место для определенного количества символов  
10) capacity() – позволяет получить текущий объем выделенной помяти  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/data/buffers.html 

Вопрос 12.    
Какие методы сравнения строк имеются в строковых классах?  
**Ответ.**  
1) метод equals() – сравнение содержимого строки.  
2) equalsIgnoreCase() - сравнение содержимого строки, причем различия регистра будут игнорированы.  
3) compareTo() - применяется, если надо определить лексикографический порядок строк. Он выполняет сравнение значения char, действуя аналогично equals().  
**Источник.**   https://otus.ru/nest/post/1272/ 

Вопрос 13.    
Используя функции строковых классов, написать фрагмент программы, которая будет определять, является ли строка палиндромом.  
**Ответ.**  
```java
public static boolean isPalindrom(String str) {
        for (int i = 0, j = str.length() - 1; i < str.length() / 2 && j > 0; i++, j--) {
            if (str.charAt(i) != str.charAt(j)) {
                return false;
            }
        }
        return true;
    }
```
**Источник.**  

Вопрос 14.   
Что появится в консоли в результате работы фрагмента программы?  
```java
final String ZA = " за ";
String value = "ОТЧЕТ о перевозках пассажиров за январь 2019 г.";
String[] monthYear = value.split(ZA)[1].split(" ",3);
System.out.println(Arrays.toString(monthYear));
```
Поясните ответ.  
**Ответ.**  
В результате будет выведен в строку следующий массив [январь, 2019, г.].  
1) value.split(ZA)[1] – выполнится разбиение строки value по параметру “ за “, в результате будет массив из 2 – элементов: [ОТЧЕТ о перевозках пассажиров, январь 2019 г.]. [1] – берется первый элемент, т. е. - январь 2019 г.].   
2) split(" ",3) – получившийся элемент массива “январь 2019 г.” Будет разделен по пробельному символу на 3 элемента массива [январь, 2019, г.].  
**Источник.**  

Вопрос 15.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String s4 = "1" + 2 + 3;
String s5 = 1 + 2 + "3";
System.out.println(s4);
System.out.println(s5);
Поясните ответ.
```
**Ответ.**
123  
33  
В java действия выполняются слева направо, если нет скобок.   
String s4 = "1" + 2 + 3 – первый символ строка, следовательно остальные символы приводятся к строке.  
String s5 = 1 + 2 + "3"; - первый символ число, следовательно следующий символ преобразуется к числу, строка остается строкой.  
**Источник.**   http://proglang.su/java/operators

Вопрос 16.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String s = "abcde ";
System.out.println(s.trim().length());
System.out.println(s.charAt(4));
System.out.println(s.indexOf('e'));
System.out.println(s.indexOf("de"));
System.out.println(s.substring(2, 4).toUpperCase());
System.out.println(s.replace('a', '1'));
System.out.println(s.contains("DE"));
System.out.println(s.startsWith("a"));
```
Поясните ответ.  
**Ответ.**  
System.out.println(s.trim().length());  
Возвращает 5  
Метод trim() убирает пробелы в начале и конце строки, получается “abcde”, метод length() возвращает длину строки, длина строки без пробела равна 5.  
System.out.println(s.charAt(4));  
Возвращает e  
Метод charAt(int i) возвращает символ по индексу 4, в строке “abcde “ символ с индексом 4 – e;  
System.out.println(s.indexOf('e'));  
Метод indexOf(char c) возвращает индекс первого вхождения символа, переданного в качестве параметра – это 4.  
System.out.println(s.indexOf("de"));  
Возвращает 3  
Метод indexOf(String str) возвращает индекс первого вхождения строки, переданной в качестве параметра – это 3, т. к. “de” начинается с d, а d под индексом 3.  
System.out.println(s.substring(2, 4).toUpperCase());  
Возвращает CD  
Метод substring(int n, int k) возвращает подстроку с индекса n до индекса k, не включительно – это cdю Метод toUpperCase() возвращает строку, преобразованную к заглавным буквам – CD.  
System.out.println(s.replace('a', '1'));  
Возвращает 1bcde   
Метод replace(char oldChar, char newChar)- заменяет символ oldChar на символ newChar.  
System.out.println(s.contains("DE"));  
Возвращает false  
Метод contains(String str) – возвращает boolean. Если строка содержит строку, переданную в параметр метода – результат true. В строке “DE” – символы заглавные, в исходной строке – символы строчные, следовательно символов “DE” нет в исходной строке – результат false.  
System.out.println(s.startsWith("a"));  
Возвращает true  
Метод startsWith(String str) возвращает true, если исходная строка начинается со строки str, переданной в качестве параметра. Строка “abcde “ начинается со строки “a”, следовательно результат true.  
**Источник.**  

Вопрос 17.  
Что появится в консоли в результате работы фрагмента программы?  
```java
StringBuilder b = new StringBuilder();  
b.append(12345).append('-');  
System.out.println(b.length());
System.out.println(b.indexOf("-"));
System.out.println(b.charAt(2));
StringBuilder b2 = b.reverse();
System.out.println(b.toString());
System.out.println(b == b2);
```
Поясните ответ.  
**Ответ.**  
```java
6  
5  
3  
-54321  
True  
```
System.out.println(b.length());  
Результат – 5;  
К объекту StringBuilder, позволяющему изменять строку, добавлена строка “12345” из 5 символов методом append(), к ней добавлен символ ‘-‘, соответственно длина строки стала равна 6, метод length() возвращает длину строки.  
System.out.println(b.indexOf("-"));  
Результат – 5;  
Исходная строка “12345-“, отсчет индексов начинается с 0, метод indexOf() возвращает индекс элемента, переданного в параметре. Элемент “-“ начинается с 5 индекса.  
System.out.println(b.charAt(2));  
Результат – 3;  
Исходная строка “12345-“, отсчет индексов начинается с 0, метод charAt() возвращает символ по индексу, переданному в параметре. Символ под индексом 2 это ‘3.  
StringBuilder b2 = b.reverse();  
System.out.println(b.toString());  
-54321  
Метод reverce() меняет последовательность символов в строке на противоположную. Следовательно, символы выводятся в обратной последовательности.  
System.out.println(b == b2);  
True  
Оператор “==” сравнивает ссылки на объекты. В строке StringBuilder b2 = b.reverse() происходит вызов метода на объекте b, при этом, так как StringBuilder это изменяемая строка, новая строка не создается, объект b изменяется, а ссылка присваивается переменной b2. В результате обе переменные ссылаются на один и тот же объект в памяти, поэтому результат true.  
**Источник.**  

Вопрос 18.  
Что появится в консоли в результате работы фрагмента программы?  
```java
StringBuilder s = new StringBuilder("abcde");
s.insert(1, '-').delete(3, 4);
System.out.println(s);
System.out.println(s.substring(2, 4));
```
Поясните ответ.   
**Ответ.**  
a-bde  
bd  
Так как объект класса StringBuilder изменяем, с объектом s ,будут происходить следующие изменения:  
s.insert(1, '-').delete(3, 4);  
К существующей строке, методом insert(), возвращающим объект StringBuilder, добавляется символ ‘-‘, переданный в качестве параметра перед индексом 1, также переданным в качестве параметра. В результате возвращается строка “a-bcde”. Далее методом delete() удаляется последовательность символов с 3 (включая) по 4 (не включая) – это символ ‘c’. Результат - строка “a-bde”;  
System.out.println(s.substring(2, 4));  
Метод substring(int start, int end) возвращает объект String, с индекса start по индекс end (не включая). В результате возвращается строки из символов с индексами 2, 3. (bd).  
**Источник.**  

Вопрос 19.  
```java
StringBuffer sb = new StringBuffer("abcde");  
sb.insert(2,"123");
sb.append("456");
sb.reverse();
```
Поясните ответ.  
**Ответ.**  
В результате выполнения в консоль не будет выведено ничего. Однако, так как объект класса StringBuffer изменяем, объект sb будет изменяться следующим образом:  
В строке sb.insert(2,"123"); в исходную строку будет вставлена подстрока “123” перед индексом 2. Результат – “ab123cde”  
В строке sb.append("456");в конец строки “ab123cde” будет добавлена подстрока “456” методом append(). Результат – “ab123cde456”.  
В строке sb.reverse(); у полученной результирующей строки изменится порядок символов на противоположный. Результат – “654edc321ba”.  
**Источник.**  

Вопрос 20.  
Каким образом можно сцепить строки Java?   
Назовите не менее 3 способов.  
**Ответ.**  
1) Оператор “+”;
2) Метод concat(String str);    
3) String s = new  StringBuffer().append("Java.")  
**Источник.**  

Вопрос 21.   
Чем отличаются пустая и нулевая строки?  
**Ответ.**  
Пустая строка отличается от нулевой ссылки тем, что в объектно-ориентированном языке программирования нулевая ссылка на тип строки не указывает на строковый объект и вызывает ошибку, если попытаться выполнить любую операцию над ней. Пустая строка по-прежнему является строкой, по которой могут быть предприняты строковые операции.  
**Источник.**   https://code-examples.net/ru/q/4945df   

Вопрос 22.   
В какой кодировке хранятся символы в строке?  
**Ответ.**  
Строки и символы в java хранятся в Unicode  
**Источник.**   http://javaway.info/v-kakoj-kodirovke-hranyatsya-stroki-v-java-kak-preobrazovat-stroku-iz-utf-8-v-windows-1251/ 

Вопрос 23.   
Какие интерфейсы реализуют классы String, StringBuffer и StringBuilder?  
**Ответ.**  
String – Serializable, Comparable, CharSequence, Constable, ConstantDesc  
StringBuffer - Serializable, Comparable, CharSequence  
StringBuilder - Serializable, Comparable, CharSequence  
**Источник.**  

Вопрос 24.   
Что такое кодовые точки и кодовые единицы?  
**Ответ.**  
Кодовая точка относится к числу, соответствующему символу в кодированном наборе символов. Допустимый диапазон от U + 0000 до U + 10FFFF. Среди них от U + 0000 до U + FFFF - основные символы, а от U + 10000 до U + 10FFFF - дополнительные символы.  
Единица кода - это 16-битный двоичный код, а кодовая точка - это один или два 16-битных двоичного кода. То есть одна кодовая точка может быть выражена как одна кодовая единица или две кодовые единицы.  
**Источник.**   https://russianblogs.com/article/56331560288/

Вопрос 25.  
Объясните назначение метода intern().  
Что появится в консоли в результате работы фрагмента программы?  
```java
class GFG {
	public static void main(String[] args) {
		String s1 = new String("GFG");
		String s2 = s1.intern();
		System.out.println(s1 == s2);
		System.out.println(s1.equals(s2));
		String s3 = "GFG";
		System.out.println(s2 == s3);
	}
}
```
Поясните ответ.  
**Ответ.**  
Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.  
Результат работы фрагмента программы:  
false  
true  
true  
String s1 = new String("GFG");  
Строка будет создана в области памяти heap, не в пуле строк.  
String s2 = s1.intern();  
Строка будет добавлена в специальную область памяти heap - пул строк. Соответственно в памяти будет находится 2 строки, одна в пуле строк, а вторая в heap. И ссылки на них будут разные. Следовательно s1 == s2 дает false, так как оператор == сравнивает ссылки на объекты. А s1.equals(s2) возвращает true, так как у класса String есть переопределенный метод equals(), а строки s1 и s2 имеют одинаковое содержание. В строке String s3 = “GFG”; происходит попытка создать объект со значением “GFG” в пуле строк, однако такая строка уже имеется там и следовательно будут возвращена лишь ссылка на существующий объект. Следовательно у объектов s2 и s3 будут одинаковые ссылки, значит s2 == s3 вернет true.  
**Источник.**   https://javarush.ru/groups/posts/760-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch2 

Вопрос 26.  
Как преобразовать строку в число?  
**Ответ.**  
Для преобразования строки в число необходимо использовать классы обертки над примитивными типами и их соответствующие методы.   
Класс Byte и его методы valueOf() и parseByte();  
Класс Short и его методы valueOf() и parseShort();  
Класс Integer и его методы valueOf() и parseInt ();  
Класс Long и его методы valueOf() и parseLong ();  
Класс Double и его методы valueOf() и parseDouble ();  
Класс Integer и его методы valueOf() и parseFloat ();  
**Источник.**   https://otus.ru/nest/post/1042/ 

Вопрос 27.  
Какой метод вызывается для преобразования переменной в строку?  
**Ответ.**  
Для преобразования строки в число необходимо использовать классы обертки над примитивными типами и их соответствующие методы.  
Преобразование int to String в Java:  
   int i = 53;  
   String str = Integer.toString(i);  
   System.out.println(str);     
Аналогично работает и для других примитивных числовых типов данных в Java: byte, short, long, float, double, меняя соответствующим образом названия классов и методов.  
**Источник.**   https://otus.ru/nest/post/1042/

Вопрос 28.  
Каким методом в классе String можно проверить строку на соответствие регулярному выражению?  
**Ответ.**  
Метод matches() принимает регулярное выражение и возвращает true, если строка соответствует этому выражению. Иначе возвращает false.  
**Источник.**   https://metanit.com/java/tutorial/7.4.php#:~:text=matches,%D0%98%D0%BD%D0%B0%D1%87%D0%B5%20%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82%20false. 

Вопрос 29.  
Создайте класс с полями: int, long, float и double, String.   
Сделайте для этого класса метод toString(), использующий String.format(), и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.  
**Ответ.**  
```java
public class Test {
        int i = 4;
        long l = 78965;
        float f = 3.65F;
        double d = 5.556;
        String s = "One, two";

        public String toString() {
            return String.format("%d, %d, %.2f, %.3f, %s", i, l, f, d, s);
        }
   }
   ```
**Источник.**  

Вопрос 30.  
Опишите:   
•	назначение класса Formatter,   
•	методы format(),   
•	спецификаторы формата.  
**Ответ.**  
Для создания форматированного текстового вывода предназначен класс java.util.Formatter. Этот класс обеспечивает преобразование формата, позволяющее выводить числа, строки, время и даты в любом необходимом разработчику виде.  
В классе Formatter объявлен метод format(), который преобразует переданные в него параметры в строку заданного формата и сохраняет в объекте типа Formatter.  

**Источник.**   https://leodev.ru/blog/java/%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81%D1%82%D1%80%D0%BE%D0%BA-java/#.Yji0_-rP2Uk 

Вопрос 31.  
Что представляет собой регулярное выражение?   
На каких классах базируются regex-возможности языка Java?   
В каком пакете эти классы расположены?  
**Ответ.**  
Регулярное выражение (RegEx) – это шаблон для поиска строки в тексте.  
Regex возможности языка базируются на 2 – х классах: Pattern и Matcher.  
Они находятся в пакете java.util.regex.  
**Источник.**   https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java 

Вопрос 32.  
Опишите назначение классов Pattern и Matcher.   
Каким образом они связываются?   
Предоставить простейший код их взаимодействия.  
**Ответ.**  
Matcher  
Этот класс интерпретирует шаблон и определяет совпадения в водимой строке.  
Pattern  
Класс Pattern предоставляет нам скомпилированный вариант регулярного выражения.  
В классе Pattern определен метод matcher(String input), который в качестве параметра принимает строку, где надо проводить поиск, и возвращает объект Matcher:  
Pattern pattern = Pattern.compile("hello");  
Matcher matcher = pattern.matcher(input);  
```java
public static void main(String[] args) {
         
        String input = "Hello";
        Pattern pattern = Pattern.compile("Hello");
        Matcher matcher = pattern.matcher(input);
        boolean found = matcher.matches();
        if(found)
            System.out.println("Найдено");
        else
            System.out.println("Не найдено");
    } 
  ```
**Источник.**   https://metanit.com/java/tutorial/7.4.php 

Вопрос 33.  
При помощи регулярных выражений найти все ссылки внутри веб-страницы, то есть адреса, указанные в атрибуте href.  
**Ответ.**  
<a\\s.*?href=\"(.+?)\".*?>(.+?)</a>  
**Источник.**  

Вопрос 34.  
Какой из способов сравнения строк предпочтительнее?  
str.equals("abc");  
или  
"abc".equals(str);  
Поясните ответ.  
**Ответ.**  
В первом случае есть вероятность получить NullPointerException. Следовательно правильно было бы изначально сравнить str с null, str != null && str.equals("abc").   
Во второй записи проверка на null не нужна.  
**Источник.**   http://www.skipy.ru/technics/strings.html

Вопрос 35.  
Как сравнить объекты StringBuilder и StringBuffer?  
**Ответ.**  
В классах StringBuilder и StringBuffer есть метод toString(), который возвращает содержимое объектов в виде объекта String. Перед сравнением необходимо привести оба объекта к классу String при помощи метода toString() и сравнить две строки, используя метод equals().  
**Источник.**   https://ru.stackoverflow.com/questions/654773/%D0%9A%D0%B0%D0%BA-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D1%8C-string-%D0%B8-stringbuffer 

Вопрос 36.  
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.printf(
	"%d студентов пришли сдавать зачет по %8.10s, \n" 
	+ "из них не сдали %d, %s", 
	10, "J2SE", 5, "а остальные сдали на отлично"
);
```
Поясните ответ.  
**Ответ.**  
10 студентов пришли сдавать зачет по     J2SE,   
из них не сдали 5, а остальные сдали на отлично  
Первый параметр это шаблон, согласно которому будет происходить форматирование.    
“%d” означает подстановку параметра, следующего первым за шаблоном для форматирования, где d - вывод десятичного числа, следовательно перед строкой будет добавлено число 10. Следующим для подстановки берется “%8.10s”, где 8 – число  обозначающее то, что если количество знаков в числе меньше, чем 8, то оно будет спереди дополнено пробелами на недостающее (до 8-и), следовательно перед строкой “J2SE” будет добавлено 4 пробела, “.10s” указывает то, что аргумент это строка (символ s) и то, что ограничено количество символов до 10 (.10). Символ \n выполняет перенос на следующую строку. Далее “%d” просто выведет десятичное число 5 (символ d) в строку на свое место, а “%s” выведет очередной аргумент – строку (символ s).   
**Источник.**   http://study-java.ru/uroki-java/formatirovanie-chisel-i-texta-v-java/ 

Вопрос 37.  
Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с "http" или "https" и заканчивающиеся на "by".  
**Ответ.**  
https?:\\/\\/(?:[-\\w]+\\.)?([-\\w]+)\\.by  
**Источник.**  

Вопрос 38.  
Сформировать регулярное выражение, при помощи которого можно выбрать все значения URL-запроса с ресурса https://bsut.by.  
Например, запрос https://bsut.by?value1=5&value2=10&iscan=true.  
Вывод  
value1=5  
value2=10  
iscan=true  
**Ответ.**  
```java
class Runner {
    public static void main(String[] args) {
        String input = "https://bsut.by?value1=5&value2=10&iscan=true";
        Pattern pattern = Pattern.compile("[a-z]+\\d?=(\\w+)");
        Matcher matcher = pattern.matcher(input);
        while (matcher.find()){
            System.out.println(matcher.group());
        }
    }
}
```
**Источник.**  

Вопрос 39.  
Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). Специальные символы, основные логические конструкции, предопределенные классы символов, логические операции, квантификаторы, группы.  
**Ответ.**  
Для написания регулярного выражения используются буквенные и цифровые символы, а также метасимволы – символы, имеющие специальное значение в синтаксисе регулярных выражений.  
``String regex=”java”; // шаблон строки ”java”;``  
``String regex=”\\d{3}”; // шаблон строки из трех цифровых символов;``  
Метасимволы для поиска совпадений границ строк или текста  
^	начало строки  
$	конец строки  
\b	граница слова  
\B	не граница слова  
\A	начало ввода  
\G	конец предыдущего совпадения  
\Z	конец ввода  
\z	конец ввода  

Метасимволы для поиска символьных классов  
\d	цифровой символ  
\D	нецифровой символ  
\s	символ пробела   
\S	непробельный символ  
\w	буквенно-цифровой символ или знак подчёркивания  
\W	любой символ, кроме буквенного, цифрового или знака подчёркивания  
.	любой символ  

Метасимволы для поиска символов редактирования текста  
\t	символ табуляции  
\n	символ новой строки  
\r	символ возврата каретки  
\f	переход на новую страницу  
\u 0085	символ следующей строки  
\u 2028	символ разделения строк  
\u 2029	символ разделения абзацев  

Метасимволы для группировки символов  
[абв]	любой из перечисленных (а,б, или в)  
[^абв]	любой, кроме перечисленных (не а,б, в)  
[a-zA-Z]	слияние диапазонов (латинские символы от a до z без учета регистра )  
[a-d[m-p]]	объединение символов (от a до d и от m до p)  
[a-z&&[def]]	пересечение символов (символы d,e,f)  
[a-z&&[^bc]]	вычитание символов (символы a, d-z)  

Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа или группы символов.  
?	один или отсутствует  
*	ноль или более раз  
+	один или более раз  
{n}	n раз  
{n,}	n раз и более  
{n,m}	не менее n раз и не более m раз  

Флаги  
Существует пять необязательных флагов регулярных выражений. Они могут использоваться совместно или раздельно, их помещают после закрывающего слэша. Регулярные выражения с флагами выглядят так: /[A-Z]/g.  
g — глобальный поиск (обрабатываются все совпадения с шаблоном поиска);  
i — регистр букв не имеет значения;  
m — многострочный поиск;  
s — текст трактуется как одна строка, в этом случае метасимволу . (точка) соответствует любой одиночный символ, включая символ новой строки;  
u — unicode трактовка. Выражение может содержать специальные паттерны, характерные для юникода, например, /\p{Lu}/ - заглавные буквы.  

Синтаксис регулярных выражений основан на использовании символов ``<([{\^-=$!|]})?*+.>``, которые можно комбинировать с буквенными символами.  
Чтобы создать RegEx в Java, нужно сделать два простых шага:  
1) написать его в виде строки с учётом синтаксиса регулярных выражений;  
2) скомпилировать эту строку в регулярное выражение;   

Квантификаторы позволяют задавать количество вхождений символа в строку.  
"А.+а" // жадный режим  
"А.++а" // сверхжадный режим  
"А.+?а" // ленивый режим  
По умолчанию квантификатор работает в жадном режиме. Это означает, что он ищет максимально длинное совпадение в строке.  

Круглые скобки используются для определения области действия и приоритета операций. Шаблон внутри группы обрабатывается как единое целое и может быть квантифицирован

Группы фиксации являются способом обработать многократные символы как единый блок. Они создаются, помещая символы, которые будут сгруппированы в ряде круглых скобок. Например, регулярное выражение (dog) создает единственную группу, содержащую буквы "d" "o" и "g".
группы фиксации перечисляются, считая их вводные круглые скобки слева направо. В выражении ((A)(B(C))), например, есть четыре таких группы:

1) ((A)(B(C)))  
2) (A)  
3) (B(C))  
4) (C)  
Есть также специальная группа, группа 0, которая всегда представляет все выражение. Эта группа не включается в общее количество

**Источник.**  https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java  

Вопрос 40.  
Назовите основные, на ваш взгляд, методы класса Pattern.  
**Ответ.**  
Метод compile() возвращает объект Pattern, который мы затем можем использовать в программе.  
метод matcher(String input), который в качестве параметра принимает строку, где надо проводить поиск, и возвращает объект Matcher  
**Источник.**   https://metanit.com/java/tutorial/7.4.php  

Вопрос 41.  
Назовите основные, на ваш взгляд, методы класса Matcher.  
**Ответ.**  
boolean matches(): возвращает true, если вся строка совпадает с шаблоном  
boolean find(): возвращает true, если в строке есть подстрока, которая совпадает с шаблоном, и переходит к этой подстроке  
String group(): возвращает подстроку, которая совпала с шаблоном в результате вызова метода find. Если совпадение отсутствует, то метод генерирует исключение IllegalStateException.  
int start(): возвращает индекс текущего совпадения  
int end(): возвращает индекс следующего совпадения после текущего  
String replaceAll(String str): заменяет все найденные совпадения подстрокой str и возвращает измененную строку с учетом замен  
**Источник.**  https://metanit.com/java/tutorial/7.4.php 

Вопрос 42.  
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.println{"-1234".matches("-?\\d+"));  
System. out. println ("5678". matches (" - ?\ \d+"));  
System.out.println("+9ll".matches("-?\\d+"));  
System.out.println("+911".matches("(-|\\+)?\\d+"));  
```
Поясните ответ.  
**Ответ.**  
true  
Ошибка компиляции  
false  
true  
Метод matches() — в Java сообщает, соответствует ли или нет данная строка заданному регулярному выражению.  
в первой строке "-1234", регулярное выражение будет искать строку, содержащую знак '-', который должен присутствовать 1 или 0 раз (на это указывает квантификатор "?"), далее знак "\\d" будет искать цифровые символы, содержащиеся один и более раз (квантификатор "+").    
во второй строке "5678" ошибка компиляции из за ошибки в регулярном выражении. (необходимо писать без пробела \\d)  
в третьей строке "+911" - результат false, т.к. в строке присутствует знак +, который не указан в регулярном выражении.  
в четвертой строке "+911" - результат true, т.к. часть регулярного выражения "(-|\\+)?" будет искать либо символ "-" или "+", содержащиеся 1 или 0 раз.  
**Источник.**  

Вопрос 43.  
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.println(
	Arrays
	.toString("Then, when you have found the gold."
		.split("n\\W+")
	)
);
```
Поясните ответ.  
**Ответ.**  
[The, whe, you have found the gold.]  
Метод split() будет разделять строку по следующему регулярному выражению "n\\W+", где разделителем служит символ n и следующие за ним любые символы, кроме буквенного, цифрового или знака подчёркивания (\\W), а также символ + указывает на количество повторений “\\W” – 1 или несколько раз. Следовательно, если после символа n будет не буквенный, не цифровой символы и не знак подчеркивания, строка будет разделена в этом месте.  
**Источник.**  

Вопрос 44.  
Сформируйте и протестируйте регулярное выражение, которое проверяет, что предложение начинается с прописной буквы и завершается точкой.  
**Ответ.**  
```java
class Runner {
    public static void main(String[] args) {
        String input = "Практический опыт показывает, что повышение уровня гражданского сознания требует от нас анализа новых предложений.";
        System.out.println(input.matches("[А-я][а-я\\d]*([\s,-:;]+[а-я\\d]+)*[.]"));
    }
}
```
**Источник.**  

Вопрос 45.  
Сформируйте и протестируйте регулярное выражение, которое заменяет все гласные подчеркиваниями в предложении  
"Then, when you have found the gold".  
**Ответ.**  
```java
class Runner {
    public static void main(String[] args) {
        String input = "Then, when you have found the gold";
        String myStr =input.replaceAll("[AEIOUYaeiouy]", "_");
        System.out.println(myStr);
    }
}
```
**Источник.**  

Вопрос 46.  
Определите, будет ли найдено в строке   
"Java now has regular expressions"   
совпадение для следующих выражений:  
^Java  
\Breg.*  
n.w\s+h(a|i)s  
s?  
s*  
s+  
S{4}  
S{1}  
S{0,3}  
Поясните ответ.  
**Ответ.**  
^Java - будет. регулярное выражение ``^Java`` проверяет, начинается ли строка со слова Java (метасимвол ^ указывает на начало строки).  
\Breg.*   
n.w\s+h(a|i)s - найдет подстроку "now has". Регулярное выражение ищет следующую последовательность символов: первую букву n, далее любой символ, далее буква w, за ней пробел (один или более раз), далее букву h, за которой могут быть буквы a или i, далее буква s.  
s?  
s*   
s+ - найдет символ s, который может повторяться 1 или несколько раз.  
S{4} - будет искать символ s, который должен повторяться 4 раза. В исходной строке отсутствует.  
S{1} - найдет символ s, который повторяется 1 раз.  
S{0,3} - будет искать соответствие символу s от 0 до 3 раз. данного совпадения нет в тексте.  
**Источник.**  

Вопрос 47.  
Примените регулярное выражение  
(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b  
к строке  
"Arline ate eight apples and one orange while Anita hadn't any"  
Поясните ответ.  
**Ответ.**  
**Источник.**  

Вопрос 48.  
Какие подстроки извлекают следующие регулярные выражения?  
[0-6]  
[^n-p]  
[A-Za-z0-9_]  
\w  
[A-C][n-p][a-c]  
waz{3,5}up  
[abc]+  
.*  
**Ответ.** 
[0-6]  - цифру, состоящую из 1 символа от 0 до 6  
[^n-p]  -  любой символ, кроме n, o, p  
[A-Za-z0-9_] -  символ, соответствующий одному из критериев: от A до Z заглавными, от a до z строчными, от 0 до 9 или знак _  
\w - буквенно-цифровой символ или знак подчёркивания    
[A-C][n-p][a-c] - подстроку у которой первый символ A, B или С, второй - n, o или p, третий символ a, b или с  
waz{3,5}up - подстроку, которая начинается на waz, где z может повторяться от 3 до 5 раз (например wazzzzz) и оканчивается на up (например wazzzup)  
[abc]+ - подстроку, которая содержит последовательность символов abc в любой последовательности и повторяющихся 1 и более раз.   
.* - любой символ, который повторяется 0 или более раз.  
**Источник.**  

Вопрос 49.  
Сформируйте регулярное выражение, которое находит предложения, начинающиеся с "Input:" и заканчивающиеся на "successful".  
**Ответ.**  
[I]nput[\sa-z,-:;]+successfull[!?\.]  
**Источник.**  

Вопрос 50  
Сформируйте регулярное выражение, которое выделяет в обрабатываемом тексте названия файлов (имя + расширение) графических форматов gif, png, jpg.  
**Ответ.**  
[A-Za-z[^!\/:\"<>\\]+][\sa-z,-:;[^!\/:\"<>\\]]+[\.](gif|png|jpg)  
**Источник.**  


