Вопрос 1.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String a = "java";
a.toUpperCase();
System.out.println(a);
```
**Ответ.**   
java  
**Источник.**  

Вопрос 2.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String s1 = "Java";
String s2 = "Java";
String s3 = new String("Java");
System.out.println("s1 == s2 : " + (s1 == s2));
System.out.println("s1 == s3 : " + (s1 == s3));
System.out.println(s1.equals(s3));
```
Поясните ответ.  
**Ответ.**  
```java
s1 == s2 : true
s1 == s3 : false
true
```
1) Оператор == сравнивает не свойства объектов, а ссылки.  
В первой и второй строке, при создании объекта типа ``String``, объект создается в пуле строк. При создании во второй строке объекта s2, java проверяет пул и если там присутствует такая строка, то ссылка будет указывать на тот же адрес в пуле строк, где эта строка хранится. Следовательно у s1 и s2 одинаковые ссылки, значит  (``s1 == s2 : true``).  
2) Оператор new при создании объекта принудительно выделяет для него новую область в памяти. И строка, созданная с помощью new, не попадает в String Pool: она становится отдельным объектом, даже если ее текст полностью совпадает с такой же строкой из String Pool. Следовательно и ссылки у объектов разные, поэтому ``s1 == s3 : false``.  
3) У класса ``String`` есть переопределенный метод equals(), который сравнивает не ссылки, а содержимое строк, следовательно ``s1.equals(s3)`` дает true, так как содержимое строк одинаково.  
**Источник.**   https://javarush.ru/groups/posts/equals-java-sravnenie-strok 

Вопрос 3.  
Можно ли выполнить наследование от класса ``String``?   
Почему?  
**Ответ.**  
Нет, класс ``String`` объявлен ``final``.  
**Источник.**   https://proghub.ru/q/8b7bbe 

Вопрос 4.  
Назовите основные, на ваш взгляд, методы класса ``String``.    
**Ответ.**  
•	``concat()``: объединяет строки  
•	``valueOf()``: преобразует объект в строковый вид  
•	``join()``: соединяет строки с учетом разделителя  
•	``сompareTo()``: сравнивает две строки  
•	``charAt()``: возвращает символ строки по индексу  
•	``getChars()``: возвращает группу символов  
•	``equals()``: сравнивает строки с учетом регистра  
•	``equalsIgnoreCase()``: сравнивает строки без учета регистра  
•	``regionMatches()``: сравнивает подстроки в строках  
•	``length()``: определение длины строк  
•	``isEmpty()``: возвращает true, если длина строки равна 0 
•	``format()``: генерирует форматированную строку, полученную с использованием формата, интернационализации и др.  
•	``indexOf()``: находит индекс первого вхождения подстроки в строку  
•	``lastIndexOf()``: находит индекс последнего вхождения подстроки в строку  
•	``startsWith()``: определяет, начинается ли строка с подстроки  
•	``endsWith()``: определяет, заканчивается ли строка на определенную подстроку  
•	``intern()``: заносит строку в "пул" литералов и возвращает ее объектную ссылку  
•	``replace()``: заменяет в строке одну подстроку на другую  
•	``trim()``: удаляет начальные и конечные пробелы  
•	``split()``: поиск вхождения в строку заданного регулярного выражения и деление исходной строки в соответствии с этим на массив строк  
•	``contentEquals()``: сравнение строки и содержимого объекта типа StringBuffer  
•	``substring()``: возвращает подстроку, начиная с определенного индекса до конца или до определенного индекса  
•	``toLowerCase()``: переводит все символы строки в нижний регистр  
•	``toUpperCase()``: переводит все символы строки в верхний регистр  
**Источник.**  https://metanit.com/java/tutorial/7.1.php 

Вопрос 5.  
Какие разновидности конструкторов использует класс String?  
**Ответ.**  
1) Конструктор, позволяющий создать строку, записав ее в двойных кавычках  
``String s1 =”java”``;
2) Конструктор, позволяющий создать строку через оператор new, передав в параметры строку.  
``String s2 = new String (“java”)``;
3) Конструктор, позволяющий создать строку через массив символов.  
```java
char[] chars = { 'j', 'a', 'v', 'a' };  
String s3 = new String(chars);  
```
4) Конструктор, позволяющий создать пустую строку.   
``String s4 = new String();``
5)  Конструктор, позволяющий задать диапазон символьного массива.   
```java
char[] chars = {'j', 'a', 'v', 'a', 'm', 'a', 'r', 'a', 'n' };
String str = new String(chars, 0, 3);
```
6) Конструктор, принимающий массив byte  
```java
String str = new String(byte[] asciichar)
```
7) Конструктор, принимающий объект StringBuffer  
```java
Strong str = new String(StringBuffer sbuf)
```
8) Конструктор, принимающий объект StringBuilder  
```java
String str = new String(StringBuilder sbuild) 
```
**Источник.**  http://developer.alexanderklimov.ru/android/java/string.php 

Вопрос 6.  
Какие классы в стандартной библиотеке Java работают со строками?  
**Ответ.**  
Реализация строк на Java представлена тремя основными классами: ``String``, ``StringBuffer``, ``StringBuilder``.  
Для форматирования и обработки строк применяются классы ``Formatter``, ``Pattern``, ``Matcher`` и другие.
**Источник.**   https://habr.com/ru/post/260767/ 

Вопрос 7.  
Почему экземпляры класса String в Java неизменные и финализированные?  
**Ответ.**  
1)	Строковый пул возможен только потому, что строка неизменна в Java, таким образом виртуальная машина сохраняет много места в памяти(heap space), поскольку разные строковые переменные указывают на одну переменную в пуле. Если бы строка не была неизмененяемой, тогда бы интернирование строк не было бы возможным, потому что если какая-либо переменная изменит значение, это отразится также и на остальных переменных, ссылающихся на эту строку  
2)	Если строка будет изменяемой, тогда это станет серьезной угрозой безопасности приложения. Например, имя пользователя базы данных и пароль передаются строкой для получения соединения с базой данных и в программировании сокетов реквизиты хоста и порта передаются строкой. Так как строка неизменяемая, её значение не может быть изменено, в противном случае любой хакер может изменить значение ссылки и вызвать проблемы в безопасности приложения.  
3)	Так как строка неизменная, она безопасна для многопоточности и один экземпляр строки может быть совместно использован различными потоками. Это позволяет избежать синхронизации для потокобезопасности, строки полностью потокобезопасны.  
4)	Строки используются в Java classloader и неизменность обеспечивает правильность загрузки класса при помощи Classloader. К примеру, задумайтесь об экземпляре класса, когда вы пытаетесь загрузить java.sql.Connection класс, но значение ссылки изменено на myhacked.Connection класс, который может осуществить нежелательные вещи с вашей базой данных.  
5)	Поскольку строка неизменная, её hashcode кэшируется в момент создания и нет необходимости рассчитывать его снова. Это делает строку отличным кандидатом для ключа в Map и его обработка будет быстрее, чем других ключей HashMap. Это причина, почему строка наиболее часто используемый объект в качестве ключа HashMap.  
**Источник.**   https://javastudy.ru/interview/strings/#:~:text=22.-,%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83%20%D1%81%D1%82%D1%80%D0%BE%D0%BA%D0%B0%20%D0%BD%D0%B5%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B8%20%D1%84%D0%B8%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%B2%20Java%3F,%D0%BD%D0%B0%20%D0%BE%D0%B4%D0%BD%D1%83%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%83%D1%8E%20%D0%B2%20%D0%BF%D1%83%D0%BB%D0%B5. 

Вопрос 8.  
Заполните ячейки таблицы (Да/Нет).  
Characteristic 				String		StringBuilder		StringBuffer  
Неизменяемый (Immutable)?	  
Имеет пул (Pooled)?                          
Потокобезопасный (Thread-safe)?   
Может изменять размер?                 
**Ответ.**  
Characteristic 				                 String		          StringBuilder		            StringBuffer  
Неизменяемый (Immutable)?	               Да                  Нет                           Нет  
Имеет пул (Pooled)?                      Да                  Нет                           Нет  
Потокобезопасный (Thread-safe)?          Да                  Нет                           Да  
Может изменять размер?                   Нет                 Да                            Да  
**Источник.**   https://javarush.ru/groups/posts/2351-znakomstvo-so-string-stringbuffer-i-stringbuilder-v-java 

Вопрос 9.  
В чем разница и что общего между StringBuffer и StringBuilder?  
**Ответ.**  
Общее то, что объекты двух классов изменяемы, а отличие в том, что класс StringBuilder не является потокобезопасным, а StringBuffer – потокобезопасен.   
**Источник.**   https://docs.oracle.com/javase/tutorial/java/data/buffers.html 

Вопрос 10.   
Когда лучше использовать StringBuffer, а когда StringBuilder?  
**Ответ.**  
Классы StringBuffer и StringBuilder используются в случаях, когда необходимо модифицировать строку. Класс StringBuffer лучше использовать в мультипоточной среде. В однопоточной среде лучше StringBuilder, так как он быстрее.  
**Источник.**   http://www.quizful.net/interview/java/string-stringbuffer-difference#:~:text=%D0%9A%D0%BB%D0%B0%D1%81%D1%81%20StringBuffer%20%D1%8F%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F%20mutable%20%2D%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C,%D1%87%D1%82%D0%BE%20%D0%B4%D0%B5%D0%BB%D0%B0%D0%B5%D1%82%20%D0%B5%D0%B3%D0%BE%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%20%D1%88%D1%83%D1%81%D1%82%D1%80%D0%B5%D0%B5. 

Вопрос 11.  
Какие методы имеются в классах StringBuffer и StringBuilder, которые отсутствуют в классе String?  
**Ответ.**  
1) append() – добавляющий подстроку в существующий объект StringBuilder/StringBuffer.  
2) delete() – выполняющий удаление по индексу в объекте StringBuilder/StringBuffer  
3) insert() – выполняющий вставку элемента в объект StringBuilder/StringBuffer  
4) replace() – заменяющий элементы в объекте StringBuilder/StringBuffer  
5) setCharAt() – выполняющий вставку в объекта StringBuilder/StringBuffer  
6) reverse() – меняющий последовательность символов на обратную в объекте StringBuilder/StringBuffer  
7) setLength() – устанавливает длину строки.  
8) ensureCapacity() – выделяет место для определенного количества символов  
9) capacity() – позволяет получить текущий объем выделенной помяти  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/data/buffers.html 

Вопрос 12.    
Какие методы сравнения строк имеются в строковых классах?  
**Ответ.**  
1) метод boolean equals(Object anObject) – сравнение содержимого строки.  
2) boolean equalsIgnoreCase(String anotherString) - возвращает true, когда аргумент является строковым объектом, представляющим ту же последовательность символов, что и этот объект, игнорируя различия в регистре. 
3) int compareTo(String anotherString) - применяется, если надо определить лексикографический порядок строк. Он выполняет сравнение значения char, действуя аналогично equals().  
4) int compareToIgnoreCase(String str) - применяется, если надо определить лексикографический порядок строк, при чем регистр символов игнорируется. Он выполняет сравнение значения char, действуя аналогично equals().  
5) методы boolean endWith(String suffix), boolean startsWith(String prefix) - возвращают true, если строка заканчивается или начинается с подстроки, переданной в аргумент метода.  
6) boolean startsWith(String prefix, int offset) - читает строку, начинающуюся со смещением индекса, и возвращает значение true, если она начинается с подстроки, указанной в качестве аргумента.  
7) boolean regionMatches(int toffset, String other, int ooffset, int len) - Проверяет, соответствует ли указанная область этой строки указанной области строкового аргумента.
toffset — начальное смещение субобласти в этой строке;  
other — строковый аргумент;  
ooffset — начальное смещение субобласти в строковом аргументе;  
len — количество символов для сравнения;  
8) boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) 
toffset — начальное смещение субобласти в этой строке;  
other — строковый аргумент;  
ooffset — начальное смещение субобласти в строковом аргументе;  
len — количество символов для сравнения;  
ignoreCase — значение true, если не учитывать регистр при сравнении символов.  
9) boolean matches(String regex) - проверяет, соответствует ли эта строка указанному регулярному выражению.  
**Источник.**   https://docs.oracle.com/javase/tutorial/java/data/comparestrings.html  

Вопрос 13.    
Используя функции строковых классов, написать фрагмент программы, которая будет определять, является ли строка палиндромом.  
**Ответ.**  
```java
public class Runner {
   public static void main(String[] args) {
      String stringForAnalyze = "aboba";
      StringBuffer stringBuffer = new StringBuffer(stringForAnalyze);
      System.out.println("Talk, what " + stringForAnalyze + " it's palindrome is: " + stringBuffer.toString().equals(stringBuffer.reverse().toString()));
   }
}
```
**Источник.**  

Вопрос 14.   
Что появится в консоли в результате работы фрагмента программы?  
```java
final String ZA = " за ";
String value = "ОТЧЕТ о перевозках пассажиров за январь 2019 г.";
String[] monthYear = value.split(ZA)[1].split(" ",3);
System.out.println(Arrays.toString(monthYear));
```
Поясните ответ.  
**Ответ.**  
В результате будет выведен в строку следующий массив [январь, 2019, г.].  
1) value.split(ZA)[1] – выполнится разбиение строки value по параметру “ за “, в результате будет массив из 2 – элементов: [ОТЧЕТ о перевозках пассажиров, январь 2019 г.]. [1] – берется первый элемент, т. е. - январь 2019 г.].   
2) split(" ",3) – получившийся элемент массива “январь 2019 г.” Будет разделен по пробельному символу на 3 элемента массива [январь, 2019, г.].  
**Источник.**  

Вопрос 15.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String s4 = "1" + 2 + 3;
String s5 = 1 + 2 + "3";
System.out.println(s4);
System.out.println(s5);
Поясните ответ.
```
**Ответ.**
123  
33  
В java действия выполняются слева направо, если нет скобок.   
String s4 = "1" + 2 + 3 – первый символ строка, следовательно остальные символы приводятся к строке.  
String s5 = 1 + 2 + "3"; - первый символ число, следовательно следующий символ преобразуется к числу, строка остается строкой.  
**Источник.**   http://proglang.su/java/operators

Вопрос 16.  
Что появится в консоли в результате работы фрагмента программы?  
```java
String s = "abcde ";
System.out.println(s.trim().length());
System.out.println(s.charAt(4));
System.out.println(s.indexOf('e'));
System.out.println(s.indexOf("de"));
System.out.println(s.substring(2, 4).toUpperCase());
System.out.println(s.replace('a', '1'));
System.out.println(s.contains("DE"));
System.out.println(s.startsWith("a"));
```
Поясните ответ.  
**Ответ.**  
System.out.println(s.trim().length());  
Возвращает 5  
Метод trim() убирает пробелы в начале и конце строки, получается “abcde”, метод length() возвращает длину строки, длина строки без пробела равна 5.  
System.out.println(s.charAt(4));  
Возвращает e  
Метод charAt(int i) возвращает символ по индексу 4, в строке “abcde “ символ с индексом 4 – e;  
System.out.println(s.indexOf('e'));  
Метод indexOf(char c) возвращает индекс первого вхождения символа, переданного в качестве параметра – это 4.  
System.out.println(s.indexOf("de"));  
Возвращает 3  
Метод indexOf(String str) возвращает индекс первого вхождения строки, переданной в качестве параметра – это 3, т. к. “de” начинается с d, а d под индексом 3.  
System.out.println(s.substring(2, 4).toUpperCase());  
Возвращает CD  
Метод substring(int n, int k) возвращает подстроку с индекса n до индекса k, не включительно – это cdю Метод toUpperCase() возвращает строку, преобразованную к заглавным буквам – CD.  
System.out.println(s.replace('a', '1'));  
Возвращает 1bcde   
Метод replace(char oldChar, char newChar)- заменяет символ oldChar на символ newChar.  
System.out.println(s.contains("DE"));  
Возвращает false  
Метод contains(String str) – возвращает boolean. Если строка содержит строку, переданную в параметр метода – результат true. В строке “DE” – символы заглавные, в исходной строке – символы строчные, следовательно символов “DE” нет в исходной строке – результат false.  
System.out.println(s.startsWith("a"));  
Возвращает true  
Метод startsWith(String str) возвращает true, если исходная строка начинается со строки str, переданной в качестве параметра. Строка “abcde “ начинается со строки “a”, следовательно результат true.  
**Источник.**  

Вопрос 17.  
Что появится в консоли в результате работы фрагмента программы?  
```java
StringBuilder b = new StringBuilder();  
b.append(12345).append('-');  
System.out.println(b.length());
System.out.println(b.indexOf("-"));
System.out.println(b.charAt(2));
StringBuilder b2 = b.reverse();
System.out.println(b.toString());
System.out.println(b == b2);
```
Поясните ответ.  
**Ответ.**  
```java
6  
5  
3  
-54321  
True  
```
System.out.println(b.length());  
Результат – 5;  
К объекту StringBuilder, позволяющему изменять строку, добавлена строка “12345” из 5 символов методом append(), к ней добавлен символ ‘-‘, соответственно длина строки стала равна 6, метод length() возвращает длину строки.  
System.out.println(b.indexOf("-"));  
Результат – 5;  
Исходная строка “12345-“, отсчет индексов начинается с 0, метод indexOf() возвращает индекс элемента, переданного в параметре. Элемент “-“ начинается с 5 индекса.  
System.out.println(b.charAt(2));  
Результат – 3;  
Исходная строка “12345-“, отсчет индексов начинается с 0, метод charAt() возвращает символ по индексу, переданному в параметре. Символ под индексом 2 это ‘3.  
StringBuilder b2 = b.reverse();  
System.out.println(b.toString());  
-54321  
Метод reverce() меняет последовательность символов в строке на противоположную. Следовательно, символы выводятся в обратной последовательности.  
System.out.println(b == b2);  
True  
Оператор “==” сравнивает ссылки на объекты. В строке StringBuilder b2 = b.reverse() происходит вызов метода на объекте b, при этом, так как StringBuilder это изменяемая строка, новая строка не создается, объект b изменяется, а ссылка присваивается переменной b2. В результате обе переменные ссылаются на один и тот же объект в памяти, поэтому результат true.  
**Источник.**  

Вопрос 18.  
Что появится в консоли в результате работы фрагмента программы?  
```java
StringBuilder s = new StringBuilder("abcde");
s.insert(1, '-').delete(3, 4);
System.out.println(s);
System.out.println(s.substring(2, 4));
```
Поясните ответ.   
**Ответ.**  
a-bde  
bd  
Так как объект класса StringBuilder изменяем, с объектом s ,будут происходить следующие изменения:  
s.insert(1, '-').delete(3, 4);  
К существующей строке, методом insert(), возвращающим объект StringBuilder, добавляется символ ‘-‘, переданный в качестве параметра перед индексом 1, также переданным в качестве параметра. В результате возвращается строка “a-bcde”. Далее методом delete() удаляется последовательность символов с 3 (включая) по 4 (не включая) – это символ ‘c’. Результат - строка “a-bde”;  
System.out.println(s.substring(2, 4));  
Метод substring(int start, int end) возвращает объект String, с индекса start по индекс end (не включая). В результате возвращается строки из символов с индексами 2, 3. (bd).  
**Источник.**  

Вопрос 19.  
```java
StringBuffer sb = new StringBuffer("abcde");  
sb.insert(2,"123");
sb.append("456");
sb.reverse();
```
Поясните ответ.  
**Ответ.**  
В результате выполнения в консоль не будет выведено ничего. Однако, так как объект класса StringBuffer изменяем, объект sb будет изменяться следующим образом:  
В строке sb.insert(2,"123"); в исходную строку будет вставлена подстрока “123” перед индексом 2. Результат – “ab123cde”  
В строке sb.append("456");в конец строки “ab123cde” будет добавлена подстрока “456” методом append(). Результат – “ab123cde456”.  
В строке sb.reverse(); у полученной результирующей строки изменится порядок символов на противоположный. Результат – “654edc321ba”.  
**Источник.**  

Вопрос 20.  
Каким образом можно сцепить строки Java?   
Назовите не менее 3 способов.  
**Ответ.**  
1) Метод insert() - в качестве позиции вставки можно указать конец строки;
2) Метод concat(String str);    
3) String s = new  StringBuffer().append("Java.")  
**Источник.**  

Вопрос 21.   
Чем отличаются пустая и нулевая строки?  
**Ответ.**  
Если инициализировать строку null-ссылкой, то на ней не смогут быть вызваны методы для обработки - в отличие от пустой строки.  
**Источник.**   https://code-examples.net/ru/q/4945df   

Вопрос 22.   
В какой кодировке хранятся символы в строке?  
**Ответ.**  
Строки и символы в java хранятся в Unicode  
**Источник.**   http://javaway.info/v-kakoj-kodirovke-hranyatsya-stroki-v-java-kak-preobrazovat-stroku-iz-utf-8-v-windows-1251/ 

Вопрос 23.   
Какие интерфейсы реализуют классы String, StringBuffer и StringBuilder?  
**Ответ.**  
String – Serializable, Comparable, CharSequence, Constable, ConstantDesc, Constable  
StringBuffer - Serializable, Comparable, CharSequence, Appendable  
StringBuilder - Serializable, Comparable, CharSequence, Appendable  
**Источник.**  

Вопрос 24.   
Что такое кодовые точки и кодовые единицы?  
**Ответ.**  
Кодовая точка относится к числу, соответствующему символу в кодированном наборе символов. Допустимый диапазон от U + 0000 до U + 10FFFF. Среди них от U + 0000 до U + FFFF - основные символы, а от U + 10000 до U + 10FFFF - дополнительные символы.  
Единица кода - это 16-битный двоичный код, а кодовая точка - это один или два 16-битных двоичного кода. То есть одна кодовая точка может быть выражена как одна кодовая единица или две кодовые единицы.  
**Источник.**   https://russianblogs.com/article/56331560288/

Вопрос 25.  
Объясните назначение метода intern().  
Что появится в консоли в результате работы фрагмента программы?  
```java
class GFG {
	public static void main(String[] args) {
		String s1 = new String("GFG");
		String s2 = s1.intern();
		System.out.println(s1 == s2);
		System.out.println(s1.equals(s2));
		String s3 = "GFG";
		System.out.println(s2 == s3);
	}
}
```
Поясните ответ.  
**Ответ.**  
Когда метод intern() вызван, если пул строк уже содержит строку, эквивалентную к нашему объекту, что подтверждается методом equals(Object), тогда возвращается ссылка на строку из пула. В противном случае объект строки добавляется в пул и ссылка на этот объект возвращается.  
Результат работы фрагмента программы:  
false  
true  
true  
String s1 = new String("GFG");  
Строка будет создана в области памяти heap, не в пуле строк.  
String s2 = s1.intern();  
Строка будет добавлена в специальную область памяти heap - пул строк. Соответственно в памяти будет находится 2 строки, одна в пуле строк, а вторая в heap. И ссылки на них будут разные. Следовательно s1 == s2 дает false, так как оператор == сравнивает ссылки на объекты. А s1.equals(s2) возвращает true, так как у класса String есть переопределенный метод equals(), а строки s1 и s2 имеют одинаковое содержание. В строке String s3 = “GFG”; происходит попытка создать объект со значением “GFG” в пуле строк, однако такая строка уже имеется там и следовательно будут возвращена лишь ссылка на существующий объект. Следовательно у объектов s2 и s3 будут одинаковые ссылки, значит s2 == s3 вернет true.  
**Источник.**   https://javarush.ru/groups/posts/760-java-string-voprosih-k-sobesedovaniju-i-otvetih-na-nikh-ch2 

Вопрос 26.  
Как преобразовать строку в число?  
**Ответ.**  
Для преобразования строки в число необходимо использовать классы обертки над примитивными типами и их соответствующие методы.   
Класс Byte и его методы valueOf() и parseByte();  
Класс Short и его методы valueOf() и parseShort();  
Класс Integer и его методы valueOf() и parseInt ();  
Класс Long и его методы valueOf() и parseLong ();  
Класс Double и его методы valueOf() и parseDouble ();  
Класс Integer и его методы valueOf() и parseFloat ();  
**Источник.**   https://otus.ru/nest/post/1042/ 

Вопрос 27.  
Какой метод вызывается для преобразования переменной в строку?  
**Ответ.**  
Для преобразования строки в число необходимо использовать классы обертки над примитивными типами и их соответствующие методы.  
Преобразование int to String в Java:  
   int i = 53;  
   String str = Integer.toString(i);  
   System.out.println(str);     
Аналогично работает и для других примитивных числовых типов данных в Java: byte, short, long, float, double, меняя соответствующим образом названия классов и методов.  
**Источник.**   https://otus.ru/nest/post/1042/

Вопрос 28.  
Каким методом в классе String можно проверить строку на соответствие регулярному выражению?  
**Ответ.**  
Метод matches() принимает регулярное выражение и возвращает true, если строка соответствует этому выражению. Иначе возвращает false.  
**Источник.**   https://metanit.com/java/tutorial/7.4.php#:~:text=matches,%D0%98%D0%BD%D0%B0%D1%87%D0%B5%20%D0%B2%D0%BE%D0%B7%D0%B2%D1%80%D0%B0%D1%89%D0%B0%D0%B5%D1%82%20false. 

Вопрос 29.  
Создайте класс с полями: int, long, float и double, String.   
Сделайте для этого класса метод toString(), использующий String.format(), и выведите содержимое полей на экран в произвольном порядке, используя спецификаторы.  
**Ответ.**  
```java
public class Test {
        int i = 4;
        long l = 78965;
        float f = 3.65F;
        double d = 5.556;
        String s = "One, two";

        public String toString() {
            return String.format("%d, %d, %.2f, %.3f, %s", i, l, f, d, s);
        }
   }
   ```
**Источник.**  

Вопрос 30.  
Опишите:   
•	назначение класса Formatter,   
•	методы format(),   
•	спецификаторы формата.  
**Ответ.**  
Для создания форматированного текстового вывода предназначен класс java.util.Formatter. Этот класс обеспечивает преобразование формата, позволяющее выводить числа, строки, время и даты в любом необходимом разработчику виде.  
В классе Formatter объявлен метод format(), который преобразует переданные в него параметры в строку заданного формата и сохраняет в объекте типа Formatter. Аналогичный метод объявлен у классов PrintStream и PrintWriter. Кроме того, у этих классов объявлен метод printf() с параметрами идентичными параметрам метода format(), который осуществляет форматированный вывод в поток, тогда как метод format() сохраняет изменения в объекте типа Formatter. Таким образом, метод printf()автоматически использует возможности класса Fomatter.  
Класс Formatter преобразует двоичную форму представления данных
в форматированный текст. Он сохраняет форматированный текст в буфере, содержимое которого можно получить в любой момент. Можно предоставить классу Formatterавтоматическую поддержку этого буфера либо задать его явно при создании объекта.  
**Источник.**   Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие. 2015. стр. 190

Вопрос 31.  
Что представляет собой регулярное выражение?   
На каких классах базируются regex-возможности языка Java?   
В каком пакете эти классы расположены?  
**Ответ.**  
Регулярное выражение (RegEx) – это шаблон для поиска строки в тексте.  
Regex возможности языка базируются на 2 – х классах: Pattern и Matcher.  
Они находятся в пакете java.util.regex.  
**Источник.**   https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java 

Вопрос 32.  
Опишите назначение классов Pattern и Matcher.   
Каким образом они связываются?   
Предоставить простейший код их взаимодействия.  
**Ответ.**  
Matcher  
Этот класс интерпретирует шаблон и определяет совпадения в водимой строке.  
Методы:  
boolean matches(): возвращает true, если вся строка совпадает с шаблоном  
boolean find(): возвращает true, если в строке есть подстрока, которая совпадает с шаблоном, и переходит к этой подстроке  
String group(): возвращает подстроку, которая совпала с шаблоном в результате вызова метода find. Если совпадение отсутствует, то метод генерирует исключение IllegalStateException.  
int start(): возвращает индекс текущего совпадения  
int end(): возвращает индекс следующего совпадения после текущего  
String replaceAll(String str): заменяет все найденные совпадения подстрокой str и возвращает измененную строку с учетом замен  
Pattern  
Класс Pattern предоставляет нам скомпилированный вариант регулярного выражения.  

В классе Pattern определен метод matcher(String input), который в качестве параметра принимает строку, где надо проводить поиск, и возвращает объект Matcher:  
Pattern pattern = Pattern.compile("hello");  
Matcher matcher = pattern.matcher(input);  
```java
public static void main(String[] args) {
         
        String input = "Hello";
        Pattern pattern = Pattern.compile("Hello");
        Matcher matcher = pattern.matcher(input);
        boolean found = matcher.matches();
        if(found)
            System.out.println("Найдено");
        else
            System.out.println("Не найдено");
    } 
  ```
 метод boolean matches(String pattern, CharSequence input) предназначен для простого поиска соответствий. Данный метод возвращает true, если последовательность символов input полностью соответствует шаблону строки.  
**Источник.**   https://metanit.com/java/tutorial/7.4.php 

Вопрос 33.  
При помощи регулярных выражений найти все ссылки внутри веб-страницы, то есть адреса, указанные в атрибуте href.  
**Ответ.**  
<a\\s.*?href=\"(.+?)\".*?>(.+?)</a>  
**Источник.**  

Вопрос 34.  
Какой из способов сравнения строк предпочтительнее?  
str.equals("abc");  
или  
"abc".equals(str);  
Поясните ответ.  
**Ответ.**  
В первом случае есть вероятность получить NullPointerException. Следовательно правильно было бы изначально сравнить str с null, str != null && str.equals("abc").   
Во второй записи проверка на null не нужна.  
**Источник.**   http://www.skipy.ru/technics/strings.html

Вопрос 35.  
Как сравнить объекты StringBuilder и StringBuffer?  
**Ответ.**  
В классах StringBuilder и StringBuffer есть метод toString(), который возвращает содержимое объектов в виде объекта String. Перед сравнением необходимо привести оба объекта к классу String при помощи метода toString() и сравнить две строки, используя метод equals().  
**Источник.**   https://ru.stackoverflow.com/questions/654773/%D0%9A%D0%B0%D0%BA-%D1%81%D1%80%D0%B0%D0%B2%D0%BD%D0%B8%D1%82%D1%8C-string-%D0%B8-stringbuffer 

Вопрос 36.  
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.printf(
	"%d студентов пришли сдавать зачет по %8.10s, \n" 
	+ "из них не сдали %d, %s", 
	10, "J2SE", 5, "а остальные сдали на отлично"
);
```
Поясните ответ.  
**Ответ.**  
10 студентов пришли сдавать зачет по     J2SE,   
из них не сдали 5, а остальные сдали на отлично  
Первый параметр это шаблон, согласно которому будет происходить форматирование.    
“%d” означает подстановку параметра, следующего первым за шаблоном для форматирования, где d - вывод десятичного числа, следовательно перед строкой будет добавлено число 10. Следующим для подстановки берется “%8.10s”, где 8 – число  обозначающее то, что если количество знаков в числе меньше, чем 8, то оно будет спереди дополнено пробелами на недостающее (до 8-и), следовательно перед строкой “J2SE” будет добавлено 4 пробела, “.10s” указывает то, что аргумент это строка (символ s) и то, что ограничено количество символов до 10 (.10). Символ \n выполняет перенос на следующую строку. Далее “%d” просто выведет десятичное число 5 (символ d) в строку на свое место, а “%s” выведет очередной аргумент – строку (символ s).   
**Источник.**   http://study-java.ru/uroki-java/formatirovanie-chisel-i-texta-v-java/ 

Вопрос 37.  
Сформировать регулярное выражение, при помощи которого можно выбрать все страницы, начинающиеся с "http" или "https" и заканчивающиеся на "by".  
**Ответ.**  
``String reg = "(https|http)://www.*by"``
**Источник.**  

Вопрос 38.  
Сформировать регулярное выражение, при помощи которого можно выбрать все значения URL-запроса с ресурса https://bsut.by.  
Например, запрос https://bsut.by?value1=5&value2=10&iscan=true.  
Вывод  
value1=5  
value2=10  
iscan=true  
**Ответ.**  
``String reg = "[?&]";``
**Источник.**  

Вопрос 39.  
Базовые конструкции регулярных выражений, синтаксис (очень коротко, суть). Специальные символы, основные логические конструкции, предопределенные классы символов, логические операции, квантификаторы, группы.  
**Ответ.**  
Для написания регулярного выражения используются буквенные и цифровые символы, а также метасимволы – символы, имеющие специальное значение в синтаксисе регулярных выражений.  
``String regex=”java”; // шаблон строки ”java”;``  
``String regex=”\\d{3}”; // шаблон строки из трех цифровых символов;``  
Метасимволы для поиска совпадений границ строк или текста  
^	начало строки  
$	конец строки  
\b	граница слова  
\B	не граница слова  
\A	начало ввода  
\G	конец предыдущего совпадения  
\Z	конец ввода  
\z	конец ввода  

Метасимволы для поиска символьных классов  
\d	цифровой символ  
\D	нецифровой символ  
\s	символ пробела   
\S	непробельный символ  
\w	буквенно-цифровой символ или знак подчёркивания  
\W	любой символ, кроме буквенного, цифрового или знака подчёркивания  
.	любой символ  

Метасимволы для поиска символов редактирования текста  
\t	символ табуляции  
\n	символ новой строки  
\r	символ возврата каретки  
\f	переход на новую страницу  
\u 0085	символ следующей строки  
\u 2028	символ разделения строк  
\u 2029	символ разделения абзацев  

Метасимволы для группировки символов  
[абв]	любой из перечисленных (а,б, или в)  
[^абв]	любой, кроме перечисленных (не а,б, в)  
[a-zA-Z]	слияние диапазонов (латинские символы от a до z без учета регистра )  
[a-d[m-p]]	объединение символов (от a до d и от m до p)  
[a-z&&[def]]	пересечение символов (символы d,e,f)  
[a-z&&[^bc]]	вычитание символов (символы a, d-z)  

Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа или группы символов.  
?	один или отсутствует  
*	ноль или более раз  
+	один или более раз  
{n}	n раз  
{n,}	n раз и более  
{n,m}	не менее n раз и не более m раз  

Флаги  
Существует пять необязательных флагов регулярных выражений. Они могут использоваться совместно или раздельно, их помещают после закрывающего слэша. Регулярные выражения с флагами выглядят так: /[A-Z]/g.  
g — глобальный поиск (обрабатываются все совпадения с шаблоном поиска);  
i — регистр букв не имеет значения;  
m — многострочный поиск;  
s — текст трактуется как одна строка, в этом случае метасимволу . (точка) соответствует любой одиночный символ, включая символ новой строки;  
u — unicode трактовка. Выражение может содержать специальные паттерны, характерные для юникода, например, /\p{Lu}/ - заглавные буквы.  

Синтаксис регулярных выражений основан на использовании символов ``<([{\^-=$!|]})?*+.>``, которые можно комбинировать с буквенными символами.  
Чтобы создать RegEx в Java, нужно сделать два простых шага:  
1) написать его в виде строки с учётом синтаксиса регулярных выражений;  
2) скомпилировать эту строку в регулярное выражение;   

Квантификаторы позволяют задавать количество вхождений символа в строку.  
"А.+а" // жадный режим  
"А.++а" // сверхжадный режим  
"А.+?а" // ленивый режим  
По умолчанию квантификатор работает в жадном режиме. Это означает, что он ищет максимально длинное совпадение в строке.  

Круглые скобки используются для определения области действия и приоритета операций. Шаблон внутри группы обрабатывается как единое целое и может быть квантифицирован

Группы фиксации являются способом обработать многократные символы как единый блок. Они создаются, помещая символы, которые будут сгруппированы в ряде круглых скобок. Например, регулярное выражение (dog) создает единственную группу, содержащую буквы "d" "o" и "g".
группы фиксации перечисляются, считая их вводные круглые скобки слева направо. В выражении ((A)(B(C))), например, есть четыре таких группы:

1) ((A)(B(C)))  
2) (A)  
3) (B(C))  
4) (C)  
Есть также специальная группа, группа 0, которая всегда представляет все выражение. Эта группа не включается в общее количество

**Источник.**  https://javarush.ru/groups/posts/regulyarnye-vyrazheniya-v-java  

Вопрос 40.  
Назовите основные, на ваш взгляд, методы класса Pattern.  
**Ответ.**  
Метод compile() возвращает объект Pattern, который мы затем можем использовать в программе.  
метод matcher(String input), который в качестве параметра принимает строку, где надо проводить поиск, и возвращает объект Matcher  
**Источник.**   https://metanit.com/java/tutorial/7.4.php  

Вопрос 41.  
Назовите основные, на ваш взгляд, методы класса Matcher.  
**Ответ.**  
boolean matches(): возвращает true, если вся строка совпадает с шаблоном  
boolean find(): возвращает true, если в строке есть подстрока, которая совпадает с шаблоном, и переходит к этой подстроке  
String group(): возвращает подстроку, которая совпала с шаблоном в результате вызова метода find. Если совпадение отсутствует, то метод генерирует исключение IllegalStateException.  
int start(): возвращает индекс текущего совпадения  
int end(): возвращает индекс следующего совпадения после текущего  
String replaceAll(String str): заменяет все найденные совпадения подстрокой str и возвращает измененную строку с учетом замен  
**Источник.**  https://metanit.com/java/tutorial/7.4.php 

Вопрос 42.  
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.println{"-1234".matches("-?\\d+"));  
System. out. println ("5678". matches (" - ?\ \d+"));  
System.out.println("+9ll".matches("-?\\d+"));  
System.out.println("+911".matches("(-|\\+)?\\d+"));  
```
Поясните ответ.  
**Ответ.**  
true  
true  
false  
true  
Четыре строки, содержащие результат определения соответствия/несоответствия строки шаблону, поданному методу matches().  
"-?\d+" ---> "-"(один раз или ни разу) + число 0-9(один и более раз).  
"(-|\+)?\d+" ---> ("-" либо "+") - один раз или ни разу + число 0-9(один и более раз).  
"-1234".matches("-?\d+") Строка может начинаться с символа "-", после чего должна идти одна и более цифр [0-9];  
"5678". matches (" - ? \ \d+") Строка должна начинаться с "-" или нет, после чего должна идти одна или более цифр [0-9];  
"+9ll".matches("-?\d+") Строка может начинаться с "-", после чего должна идти одна и более цифр [0-9]. Т.к. первым идет символ "+", то результат false;  
"+911".matches("(-|+)?\d+") Строка может начинаться с любого из символов "+" или "-", после чего должна идти одна и более цифр [0-9];  
**Источник.**  Блинов, И. Н., Романчик, В. С. Java from EPAM : учеб.-метод. пособие. 2015. стр. 177-178.  

Вопрос 43.  
Что появится в консоли в результате работы фрагмента программы?  
```java
System.out.println(
	Arrays
	.toString("Then, when you have found the gold."
		.split("n\\W+")
	)
);
```
Поясните ответ.  
**Ответ.**  
[The, whe, you have found the gold.]  
Метод split() будет разделять строку по следующему регулярному выражению "n\\W+", где разделителем служит символ n и следующие за ним любые символы, кроме буквенного, цифрового или знака подчёркивания (\\W), а также символ + указывает на количество повторений “\\W” – 1 или несколько раз. Следовательно, если после символа n будет не буквенный, не цифровой символы и не знак подчеркивания, строка будет разделена в этом месте.  
**Источник.**  

Вопрос 44.  
Сформируйте и протестируйте регулярное выражение, которое проверяет, что предложение начинается с прописной буквы и завершается точкой.  
**Ответ.**  
```java
class Runner {
    public static void main(String[] args) {
        String input = "Практический опыт показывает, что повышение уровня гражданского сознания требует от нас анализа новых предложений.";
        System.out.println(input.matches("(\p{Upper})(.+)(\.)"));
    }
}
```
**Источник.**  

Вопрос 45.  
Сформируйте и протестируйте регулярное выражение, которое заменяет все гласные подчеркиваниями в предложении  
"Then, when you have found the gold".  
**Ответ.**  
```java
class Runner {
    public static void main(String[] args) {
        String input = "Then, when you have found the gold";
        String myStr =input.replaceAll("[AEIOUYaeiouy]", "_");
        System.out.println(myStr);
    }
}
```
**Источник.**  

Вопрос 46.  
Определите, будет ли найдено в строке   
"Java now has regular expressions"   
совпадение для следующих выражений:  
^Java  
\Breg.*  
n.w\s+h(a|i)s  
s?  
s*  
s+  
S{4}  
S{1}  
S{0,3}  
Поясните ответ.  
**Ответ.**  
^Java - да, т.к. в начале строки(^) действительно есть "Java".
\Breg.* - нет, т.к. подобной комбинации символов в исходной строке нет.
n.w\s+h(a|i)s - да, т.к. буквально это означает: ["n" + какой-либо символ + пробел + "h" + "a" либо "i" + "s"], поэтому данному выражению в исходной строке вполне соответствует "now has".
s? - "s" один раз или ни разу, поэтому каждый символ технически подходит под описание.
s* - "s" ноль или более раз, поэтому итог аналогичен предыдущему.
s+ - "s" один или более раз, поэтому в строке будет найдено три совпадения.
S{4} - совпадений найдено не будет, т.к. "S" в верхнем регистре в исходной строке отсутствует в принципе, не говоря уже о четырех вхождениях.
S{1} - тождественно утверждению выше.
S{0,3} - каждый символ в строке будет подходить под данный шаблон, т.к. он предполагает поиск "S", встречающийся ноль или три раза, поэтому (по нулю), каждый символ в исходной строке теоретически является совпадением.
**Источник.**  

Вопрос 47.  
Примените регулярное выражение  
(?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b  
к строке  
"Arline ate eight apples and one orange while Anita hadn't any"  
Поясните ответ.  
**Ответ.**  
Arline ate one orange Anita - и того 5 совпадений.
(?i) - игнор регистра.
(^[aeiou])|(\s+[aeiou]) - начало строки с гласной или пробел от одного раза и выше, за ним следует гласная.
\w+?[aeiou]\b - далее любая буква от одного повторения и выше, затем следует глассная и граница.
**Источник.**  

Вопрос 48.  
Какие подстроки извлекают следующие регулярные выражения?  
[0-6]  
[^n-p]  
[A-Za-z0-9_]  
\w  
[A-C][n-p][a-c]  
waz{3,5}up  
[abc]+  
.*  
**Ответ.** 
[0-6] - символ между 0 и 6.  
[^n-p] - символ, исключая от "n" до "p".  
[A-Za-z0-9_] - символ в диапазоне a-z независимо от регистра и от 0 до 9, а также "_".  
\w - буквенно-цифровой символ или знак подчеркивания.  
[A-C][n-p][a-c] - символ от а-с в верхнем регистре + символ от n-p в нижнем регистре + от а-с в нижнем регистре.  
waz{3,5}up - "waz" три либо пять раз + "up".  
[abc]+ - симыволы "abc" один и более раз.  
.* - какой-либо символ ноль и более раз.  
**Источник.**  

Вопрос 49.  
Сформируйте регулярное выражение, которое находит предложения, начинающиеся с "Input:" и заканчивающиеся на "successful".  
**Ответ.**  
^Input.*successful
**Источник.**  

Вопрос 50  
Сформируйте регулярное выражение, которое выделяет в обрабатываемом тексте названия файлов (имя + расширение) графических форматов gif, png, jpg.  
**Ответ.**  
.+.[gif|png|jpg]
**Источник.**  


